<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cdt

	import "github.com/iceisfun/gomesh/cdt"

## Index

- [func BoundingCover\(pts \[\]types.Point, margin float64\) \(types.Point, types.Point, types.Point, types.Point\)](<#BoundingCover>)
- [func Build\(outer \[\]types.Point, holes \[\]\[\]types.Point, extras \[\]\[2\]types.Point, opts BuildOptions\) \(\*mesh.Mesh, error\)](<#Build>)
- [func BuildSimple\(outer \[\]types.Point, holes \[\]\[\]types.Point\) \(\*mesh.Mesh, error\)](<#BuildSimple>)
- [func BuildWithConstraints\(outer \[\]types.Point, holes \[\]\[\]types.Point, constraints \[\]\[2\]types.Point\) \(\*mesh.Mesh, error\)](<#BuildWithConstraints>)
- [func BuildWithOptions\(outer \[\]types.Point, holes \[\]\[\]types.Point, constraints \[\]\[2\]types.Point, opts BuildOptions\) \(\*mesh.Mesh, error\)](<#BuildWithOptions>)
- [func CleanStaleNeighbors\(ts \*TriSoup\)](<#CleanStaleNeighbors>)
- [func CleanStaleNeighborsAfterPrune\(ts \*TriSoup\)](<#CleanStaleNeighborsAfterPrune>)
- [func CountTriangles\(ts \*TriSoup\) int](<#CountTriangles>)
- [func CountVertices\(ts \*TriSoup\) int](<#CountVertices>)
- [func DedupSegments\(segments \[\]\[2\]int\) \[\]\[2\]int](<#DedupSegments>)
- [func ExportToMesh\(ts \*TriSoup, opts ...mesh.Option\) \(\*mesh.Mesh, error\)](<#ExportToMesh>)
- [func FloodFillClassify\(ts \*TriSoup, seedInside TriID, pslg \*PSLG, constrained map\[EdgeKey\]bool\) map\[TriID\]bool](<#FloodFillClassify>)
- [func InsertConstraintEdge\(ts \*TriSoup, u, v int, constrained map\[EdgeKey\]bool\) error](<#InsertConstraintEdge>)
- [func InsertConstraintLoop\(ts \*TriSoup, vertices \[\]int, constrained map\[EdgeKey\]bool\) error](<#InsertConstraintLoop>)
- [func InsertPoint\(ts \*TriSoup, loc Location, vidx int\) \(\[\]TriID, \[\]EdgeToLegalize, error\)](<#InsertPoint>)
- [func IsDelaunay\(ts \*TriSoup, constrained map\[EdgeKey\]bool\) bool](<#IsDelaunay>)
- [func IsEdgeConstrained\(edge EdgeKey, constrained map\[EdgeKey\]bool\) bool](<#IsEdgeConstrained>)
- [func IsIllegal\(ts \*TriSoup, t TriID, e int, constrained map\[EdgeKey\]bool\) bool](<#IsIllegal>)
- [func IsPointInTriangle\(ts \*TriSoup, t TriID, p types.Point\) bool](<#IsPointInTriangle>)
- [func LegalizeAround\(ts \*TriSoup, seeds \[\]EdgeToLegalize, constrained map\[EdgeKey\]bool\)](<#LegalizeAround>)
- [func LegalizeEdge\(ts \*TriSoup, t TriID, e int, constrained map\[EdgeKey\]bool\)](<#LegalizeEdge>)
- [func MarkBoundaryTriangles\(ts \*TriSoup, pslg \*PSLG\) map\[TriID\]bool](<#MarkBoundaryTriangles>)
- [func PruneByFloodFill\(ts \*TriSoup, pslg \*PSLG, constrained map\[EdgeKey\]bool\) int](<#PruneByFloodFill>)
- [func PruneOutside\(ts \*TriSoup, pslg \*PSLG\) int](<#PruneOutside>)
- [func RemoveCover\(ts \*TriSoup, coverVerts \[\]int\) int](<#RemoveCover>)
- [func SplitConstraintByVertices\(ts \*TriSoup, u, v int, constrained map\[EdgeKey\]bool\) error](<#SplitConstraintByVertices>)
- [func SuperTriangle\(pts \[\]types.Point, margin float64\) \(types.Point, types.Point, types.Point\)](<#SuperTriangle>)
- [func ValidatePSLG\(p \*PSLG\) error](<#ValidatePSLG>)
- [func ValidateTopology\(ts \*TriSoup\) error](<#ValidateTopology>)
- [type BuildOptions](<#BuildOptions>)
  - [func DefaultBuildOptions\(\) BuildOptions](<#DefaultBuildOptions>)
- [type Diagnostics](<#Diagnostics>)
  - [func GetDiagnostics\(ts \*TriSoup, constrained map\[EdgeKey\]bool\) Diagnostics](<#GetDiagnostics>)
- [type EdgeKey](<#EdgeKey>)
  - [func GetBoundaryEdges\(ts \*TriSoup\) \[\]EdgeKey](<#GetBoundaryEdges>)
  - [func NewEdgeKey\(a, b int\) EdgeKey](<#NewEdgeKey>)
- [type EdgeToLegalize](<#EdgeToLegalize>)
- [type Location](<#Location>)
- [type Locator](<#Locator>)
  - [func NewLocator\(ts \*TriSoup\) \*Locator](<#NewLocator>)
  - [func \(l \*Locator\) LocatePoint\(p types.Point\) \(Location, error\)](<#Locator.LocatePoint>)
  - [func \(l \*Locator\) LocatePointFrom\(p types.Point, start TriID\) \(Location, error\)](<#Locator.LocatePointFrom>)
- [type PSLG](<#PSLG>)
  - [func NormalizePSLG\(outer \[\]types.Point, holes \[\]\[\]types.Point, extraSegs \[\]\[2\]types.Point, eps types.Epsilon\) \(\*PSLG, error\)](<#NormalizePSLG>)
- [type PointClassification](<#PointClassification>)
  - [func ClassifyPoint\(p types.Point, outer \[\]types.Point, holes \[\]\[\]types.Point\) PointClassification](<#ClassifyPoint>)
  - [func ClassifyTriangle\(ts \*TriSoup, t TriID, pslg \*PSLG\) PointClassification](<#ClassifyTriangle>)
- [type Tri](<#Tri>)
  - [func \(t \*Tri\) Edge\(localEdge int\) \(int, int\)](<#Tri.Edge>)
- [type TriID](<#TriID>)
  - [func FindSeedTriangle\(ts \*TriSoup, pslg \*PSLG\) \(TriID, bool\)](<#FindSeedTriangle>)
- [type TriSoup](<#TriSoup>)
  - [func CompactTriSoup\(ts \*TriSoup\) \*TriSoup](<#CompactTriSoup>)
  - [func NewTriSoup\(pts \[\]types.Point, reserveTris int\) \*TriSoup](<#NewTriSoup>)
  - [func SeedTriangulation\(pts \[\]types.Point, margin float64\) \(\*TriSoup, \[\]int, error\)](<#SeedTriangulation>)
  - [func \(ts \*TriSoup\) AddTri\(a, b, c int\) TriID](<#TriSoup.AddTri>)
  - [func \(ts \*TriSoup\) FindEdgeTriangles\(a, b int\) \[\]edgeUse](<#TriSoup.FindEdgeTriangles>)
  - [func \(ts \*TriSoup\) FindTriEdge\(t TriID, a, b int\) \(int, bool\)](<#TriSoup.FindTriEdge>)
  - [func \(ts \*TriSoup\) FlipEdge\(tLeft TriID, eLeft int\) \(TriID, TriID, bool\)](<#TriSoup.FlipEdge>)
  - [func \(ts \*TriSoup\) IsDeleted\(t TriID\) bool](<#TriSoup.IsDeleted>)
  - [func \(ts \*TriSoup\) RemoveTri\(t TriID\)](<#TriSoup.RemoveTri>)
  - [func \(ts \*TriSoup\) SetNeighbors\(t TriID, n0, n1, n2 TriID\)](<#TriSoup.SetNeighbors>)
  - [func \(ts \*TriSoup\) Validate\(\) error](<#TriSoup.Validate>)


## func BoundingCover — `cdt/supertriangle.go:12`

[BoundingCover](BoundingCover)func BoundingCover(pts []types.Point, margin float64) (types.Point, types.Point, types.Point, types.Point)
BoundingCover computes a rectangle that strictly contains all points with a margin. Returns the four corners of the rectangle: \(minX, minY\), \(maxX, minY\), \(maxX, maxY\), \(minX, maxY\).


## func Build — `cdt/builder.go:50`

[Build](Build)func Build(outer []types.Point, holes [][]types.Point, extras [][2]types.Point, opts BuildOptions) (*mesh.Mesh, error)
Build constructs a Constrained Delaunay Triangulation from a PSLG.

The algorithm proceeds as follows:

1. Normalize and validate the PSLG \(merge vertices, ensure winding\)
2. Create a bounding cover \(super\-triangle or bounding box\)
3. Insert all vertices using incremental Delaunay insertion
4. Insert all constrained edges \(perimeter, holes, extra constraints\)
5. Legalize non\-constrained edges to conform to Delaunay property
6. Classify and remove triangles outside the valid region
7. Remove cover vertices and export to mesh.Mesh


## func BuildSimple — `cdt/builder.go:190`

[BuildSimple](BuildSimple)func BuildSimple(outer []types.Point, holes [][]types.Point) (*mesh.Mesh, error)
BuildSimple is a convenience wrapper that uses default options.


## func BuildWithConstraints — `cdt/builder.go:195`

[BuildWithConstraints](BuildWithConstraints)func BuildWithConstraints(outer []types.Point, holes [][]types.Point, constraints [][2]types.Point) (*mesh.Mesh, error)
BuildWithConstraints includes extra constraint edges beyond the perimeter and holes.


## func BuildWithOptions — `cdt/builder.go:200`

[BuildWithOptions](BuildWithOptions)func BuildWithOptions(outer []types.Point, holes [][]types.Point, constraints [][2]types.Point, opts BuildOptions) (*mesh.Mesh, error)
BuildWithOptions provides full control over the CDT construction process.


## func CleanStaleNeighbors — `cdt/cleanup.go:46`

[CleanStaleNeighbors](CleanStaleNeighbors)func CleanStaleNeighbors(ts *TriSoup)
CleanStaleNeighbors removes references to deleted triangles from all non\-deleted triangles.


## func CleanStaleNeighborsAfterPrune — `cdt/classify.go:103`

[CleanStaleNeighborsAfterPrune](CleanStaleNeighborsAfterPrune)func CleanStaleNeighborsAfterPrune(ts *TriSoup)
CleanStaleNeighborsAfterPrune removes references to deleted triangles.


## func CountTriangles — `cdt/cleanup.go:213`

[CountTriangles](CountTriangles)func CountTriangles(ts *TriSoup) int
CountTriangles returns the number of non\-deleted triangles.


## func CountVertices — `cdt/cleanup.go:224`

[CountVertices](CountVertices)func CountVertices(ts *TriSoup) int
CountVertices returns the number of vertices actually used by non\-deleted triangles.


## func DedupSegments — `cdt/pslg.go:168`

[DedupSegments](DedupSegments)func DedupSegments(segments [][2]int) [][2]int
DedupSegments removes duplicate segments from the list.


## func ExportToMesh — `cdt/cleanup.go:65`

[ExportToMesh](ExportToMesh)func ExportToMesh(ts *TriSoup, opts ...mesh.Option) (*mesh.Mesh, error)
ExportToMesh converts the TriSoup to a mesh.Mesh. Only non\-deleted triangles are exported. Vertices are remapped to exclude unused vertices \(like cover vertices\).


## func FloodFillClassify — `cdt/classify.go:154`

[FloodFillClassify](FloodFillClassify)func FloodFillClassify(ts *TriSoup, seedInside TriID, pslg *PSLG, constrained map[EdgeKey]bool) map[TriID]bool
FloodFillClassify uses flood fill from a seed triangle to classify connected regions. This is more robust than centroid\-based classification for complex geometries.


## func InsertConstraintEdge — `cdt/constraint.go:14`

[InsertConstraintEdge](InsertConstraintEdge)func InsertConstraintEdge(ts *TriSoup, u, v int, constrained map[EdgeKey]bool) error
InsertConstraintEdge inserts a constrained edge between vertices u and v. It walks through the triangulation and flips any edges that intersect the constraint. After insertion, the edge \(u, v\) will exist in the triangulation and be marked as constrained.


## func InsertConstraintLoop — `cdt/constraint.go:170`

[InsertConstraintLoop](InsertConstraintLoop)func InsertConstraintLoop(ts *TriSoup, vertices []int, constrained map[EdgeKey]bool) error
InsertConstraintLoop inserts a sequence of constrained edges forming a loop. This is useful for inserting perimeter boundaries and holes.


## func InsertPoint — `cdt/insert_point.go:11`

[InsertPoint](InsertPoint)func InsertPoint(ts *TriSoup, loc Location, vidx int) ([]TriID, []EdgeToLegalize, error)
InsertPoint inserts a vertex into the triangulation at the given location. Returns the IDs of the new triangles created and the edges that need legalization.


## func IsDelaunay — `cdt/legalize.go:151`

[IsDelaunay](IsDelaunay)func IsDelaunay(ts *TriSoup, constrained map[EdgeKey]bool) bool
IsDelaunay checks if the entire triangulation satisfies the Delaunay property \(ignoring constrained edges\). This is useful for validation and testing.


## func IsEdgeConstrained — `cdt/legalize.go:8`

[IsEdgeConstrained](IsEdgeConstrained)func IsEdgeConstrained(edge EdgeKey, constrained map[EdgeKey]bool) bool
IsEdgeConstrained checks if an edge is marked as constrained.


## func IsIllegal — `cdt/legalize.go:19`

[IsIllegal](IsIllegal)func IsIllegal(ts *TriSoup, t TriID, e int, constrained map[EdgeKey]bool) bool
IsIllegal checks if an edge between two triangles violates the Delaunay property. An edge is illegal if:

1. It is not a constrained edge, AND
2. The opposite vertex in the neighboring triangle is strictly inside the circumcircle of the triangle containing the edge.

Returns true if the edge should be flipped.


## func IsPointInTriangle — `cdt/locate.go:147`

[IsPointInTriangle](IsPointInTriangle)func IsPointInTriangle(ts *TriSoup, t TriID, p types.Point) bool
IsPointInTriangle checks if point p is inside triangle t. Returns true if inside or on the boundary.


## func LegalizeAround — `cdt/legalize.go:84`

[LegalizeAround](LegalizeAround)func LegalizeAround(ts *TriSoup, seeds []EdgeToLegalize, constrained map[EdgeKey]bool)
LegalizeAround performs edge legalization starting from a set of seed edges. It uses a queue to process edges that might be illegal and flips them if needed. This continues until all edges satisfy the Delaunay property \(or are constrained\).


## func LegalizeEdge — `cdt/legalize.go:145`

[LegalizeEdge](LegalizeEdge)func LegalizeEdge(ts *TriSoup, t TriID, e int, constrained map[EdgeKey]bool)
LegalizeEdge is a simpler interface that legalizes a single edge recursively. This is useful for testing or when you want to legalize a specific edge.


## func MarkBoundaryTriangles — `cdt/classify.go:120`

[MarkBoundaryTriangles](MarkBoundaryTriangles)func MarkBoundaryTriangles(ts *TriSoup, pslg *PSLG) map[TriID]bool
MarkBoundaryTriangles identifies triangles that touch the boundary \(perimeter or holes\).


## func PruneByFloodFill — `cdt/classify.go:222`

[PruneByFloodFill](PruneByFloodFill)func PruneByFloodFill(ts *TriSoup, pslg *PSLG, constrained map[EdgeKey]bool) int
PruneByFloodFill removes triangles using flood fill classification. This is more accurate than centroid\-based pruning for complex geometries.


## func PruneOutside — `cdt/classify.go:81`

[PruneOutside](PruneOutside)func PruneOutside(ts *TriSoup, pslg *PSLG) int
PruneOutside removes all triangles that are outside the valid region. A triangle is kept if its centroid is inside the outer perimeter and outside all holes.


## func RemoveCover — `cdt/cleanup.go:12`

[RemoveCover](RemoveCover)func RemoveCover(ts *TriSoup, coverVerts []int) int
RemoveCover removes triangles that reference any of the cover vertices. Cover vertices are the ones added to create the bounding box/super\-triangle.


## func SplitConstraintByVertices — `cdt/constraint.go:190`

[SplitConstraintByVertices](SplitConstraintByVertices)func SplitConstraintByVertices(ts *TriSoup, u, v int, constrained map[EdgeKey]bool) error
SplitConstraintByVertices handles the case where intermediate vertices lie on a constraint. It splits the constraint \(u, v\) into multiple segments if any vertices are found to lie exactly on the segment.


## func SuperTriangle — `cdt/supertriangle.go:117`

[SuperTriangle](SuperTriangle)func SuperTriangle(pts []types.Point, margin float64) (types.Point, types.Point, types.Point)
SuperTriangle creates a single large triangle that contains all points. This is an alternative to the bounding rectangle approach.


## func ValidatePSLG — `cdt/pslg.go:184`

[ValidatePSLG](ValidatePSLG)func ValidatePSLG(p *PSLG) error
ValidatePSLG performs additional validation on a normalized PSLG.


## func ValidateTopology — `cdt/cleanup.go:187`

[ValidateTopology](ValidateTopology)func ValidateTopology(ts *TriSoup) error
ValidateTopology checks that the triangulation has valid topology. Returns an error if any issues are found.


<a name="BuildOptions"></a>
## type BuildOptions

BuildOptions configures the CDT construction process.

	type BuildOptions struct {
	    // Epsilon tolerance for geometric operations
	    Epsilon types.Epsilon
	
	    // CoverMargin controls how much larger the initial bounding cover is
	    // relative to the input points (e.g., 0.1 = 10% margin)
	    CoverMargin float64
	
	    // RandomSeed for vertex insertion order (use fixed seed for deterministic builds)
	    RandomSeed int64
	
	    // UseFloodFill enables flood-fill based classification instead of centroid-based
	    UseFloodFill bool
	
	    // MeshOptions are passed to the final mesh constructor
	    MeshOptions []mesh.Option
	}

## func DefaultBuildOptions — `cdt/builder.go:30`

[DefaultBuildOptions](DefaultBuildOptions)func DefaultBuildOptions() BuildOptions
DefaultBuildOptions returns sensible defaults for CDT construction.


<a name="Diagnostics"></a>
## type Diagnostics

Diagnostics provides information about the CDT construction process.

	type Diagnostics struct {
	    NumVertices        int
	    NumTriangles       int
	    NumConstraints     int
	    NumBoundaryEdges   int
	    IsDelaunay         bool
	    ConstraintsRespect bool
	}

## func GetDiagnostics — `cdt/builder.go:215`

[GetDiagnostics](GetDiagnostics)func GetDiagnostics(ts *TriSoup, constrained map[EdgeKey]bool) Diagnostics
GetDiagnostics analyzes a TriSoup and returns diagnostic information.


<a name="EdgeKey"></a>
## type EdgeKey

EdgeKey represents an undirected edge between two vertex indices. The indices are always ordered \(min, max\) for consistent hashing.

	type EdgeKey struct {
	    A, B int
	}

## func GetBoundaryEdges — `cdt/cleanup.go:240`

[GetBoundaryEdges](GetBoundaryEdges)func GetBoundaryEdges(ts *TriSoup) []EdgeKey
GetBoundaryEdges returns all edges that are on the boundary \(used by only one triangle\).


## func NewEdgeKey — `cdt/types.go:18`

[NewEdgeKey](NewEdgeKey)func NewEdgeKey(a, b int) EdgeKey
NewEdgeKey constructs an EdgeKey with ordered vertex indices.


<a name="EdgeToLegalize"></a>
## type EdgeToLegalize

EdgeToLegalize represents an edge that may need to be flipped.

	type EdgeToLegalize struct {
	    T   TriID // Triangle containing the edge
	    E   int   // Local edge index (0, 1, or 2)
	}

<a name="Location"></a>
## type Location

Location describes where a point is located within the triangulation.

	type Location struct {
	    T      TriID // The containing triangle
	    OnEdge bool  // True if the point lies on an edge
	    Edge   int   // If OnEdge, which local edge (0, 1, or 2)
	}

<a name="Locator"></a>
## type Locator

Locator provides fast point location within a triangulation via walking.

	type Locator struct {
	    // contains filtered or unexported fields
	}

## func NewLocator — `cdt/locate.go:17`

[NewLocator](NewLocator)func NewLocator(ts *TriSoup) *Locator
NewLocator creates a point locator for the given triangulation.


## func LocatePoint — `cdt/locate.go:35`

[LocatePoint](Locator.LocatePoint)func (l *Locator) LocatePoint(p types.Point) (Location, error)
LocatePoint finds which triangle contains point p. Returns the location \(triangle ID and whether on edge\) or an error.


## func LocatePointFrom — `cdt/locate.go:135`

[LocatePointFrom](Locator.LocatePointFrom)func (l *Locator) LocatePointFrom(p types.Point, start TriID) (Location, error)
LocatePointFrom locates a point starting from a specific triangle. This is useful when you have a good hint about where the point might be.


<a name="PSLG"></a>
## type PSLG

PSLG represents a Planar Straight\-Line Graph with vertices and segments.

	type PSLG struct {
	    Vertices []types.Point // Deduplicated vertices
	    Segments [][2]int      // Segment endpoints (indices into Vertices)
	    Outer    []int         // Indices of outer perimeter vertices
	    Holes    [][]int       // Indices of hole vertices
	}

## func NormalizePSLG — `cdt/pslg.go:21`

[NormalizePSLG](NormalizePSLG)func NormalizePSLG(outer []types.Point, holes [][]types.Point, extraSegs [][2]types.Point, eps types.Epsilon) (*PSLG, error)
NormalizePSLG takes raw input \(outer perimeter, holes, extra constraints\) and produces a clean, validated PSLG with merged vertices and proper winding.


<a name="PointClassification"></a>
## type PointClassification

PointClassification indicates whether a point is inside, outside, or on the boundary.

	type PointClassification int

<a name="Outside"></a>

	const (
	    Outside  PointClassification = 0
	    Inside   PointClassification = 1
	    Boundary PointClassification = 2
	)

## func ClassifyPoint — `cdt/classify.go:18`

[ClassifyPoint](ClassifyPoint)func ClassifyPoint(p types.Point, outer []types.Point, holes [][]types.Point) PointClassification
ClassifyPoint determines if a point is inside the outer perimeter and outside all holes.


## func ClassifyTriangle — `cdt/classify.go:44`

[ClassifyTriangle](ClassifyTriangle)func ClassifyTriangle(ts *TriSoup, t TriID, pslg *PSLG) PointClassification
ClassifyTriangle determines if a triangle should be kept based on its position relative to the outer perimeter and holes.


<a name="Tri"></a>
## type Tri

Tri represents a triangle with three vertex indices and three neighbor references. N\[i\] is the neighbor across the edge opposite to vertex V\[i\].

	type Tri struct {
	    V   [3]int   // Vertex indices into TriSoup.V
	    N   [3]TriID // Neighbor triangle IDs (NilTri if boundary)
	}

## func Edge — `cdt/types.go:34`

[Edge](Tri.Edge)func (t *Tri) Edge(localEdge int) (int, int)
Edge returns the local edge index \(0, 1, or 2\) and its two vertex indices. Edge i is opposite to vertex V\[i\], connecting V\[\(i\+1\)%3\] to V\[\(i\+2\)%3\].


<a name="TriID"></a>
## type TriID

TriID is a unique identifier for a triangle in the TriSoup.

	type TriID int

<a name="NilTri"></a>

	const (
	    // NilTri represents an invalid or missing triangle reference.
	    NilTri TriID = -1
	)

## func FindSeedTriangle — `cdt/classify.go:205`

[FindSeedTriangle](FindSeedTriangle)func FindSeedTriangle(ts *TriSoup, pslg *PSLG) (TriID, bool)
FindSeedTriangle finds a triangle that is definitely inside the valid region. It searches for a triangle whose centroid is inside the outer perimeter and outside all holes.


<a name="TriSoup"></a>
## type TriSoup

TriSoup is a lightweight triangulation workspace with adjacency tracking.

	type TriSoup struct {
	    V   []types.Point // All vertices (including super-triangle vertices)
	    Tri []Tri         // All triangles (some may be marked deleted)
	    // contains filtered or unexported fields
	}

## func CompactTriSoup — `cdt/cleanup.go:123`

[CompactTriSoup](CompactTriSoup)func CompactTriSoup(ts *TriSoup) *TriSoup
CompactTriSoup removes deleted triangles and unused vertices from the TriSoup. This is useful for reducing memory usage after pruning operations.


## func NewTriSoup — `cdt/adjacency.go:29`

[NewTriSoup](NewTriSoup)func NewTriSoup(pts []types.Point, reserveTris int) *TriSoup
NewTriSoup creates a new empty triangulation workspace.


## func SeedTriangulation — `cdt/supertriangle.go:65`

[SeedTriangulation](SeedTriangulation)func SeedTriangulation(pts []types.Point, margin float64) (*TriSoup, []int, error)
SeedTriangulation creates an initial triangulation cover for the given points. It uses a bounding rectangle split into two triangles as the initial cover. Returns a TriSoup with the cover triangles and the indices of the cover vertices.


## func AddTri — `cdt/adjacency.go:40`

[AddTri](TriSoup.AddTri)func (ts *TriSoup) AddTri(a, b, c int) TriID
AddTri adds a triangle with vertices \(a, b, c\) and returns its ID. The triangle is added with no neighbors initially.


## func FindEdgeTriangles — `cdt/adjacency.go:253`

[FindEdgeTriangles](TriSoup.FindEdgeTriangles)func (ts *TriSoup) FindEdgeTriangles(a, b int) []edgeUse
FindEdgeTriangles returns the triangles that share the edge \(a, b\).


## func FindTriEdge — `cdt/adjacency.go:114`

[FindTriEdge](TriSoup.FindTriEdge)func (ts *TriSoup) FindTriEdge(t TriID, a, b int) (int, bool)
FindTriEdge finds which local edge \(0, 1, or 2\) connects vertices a and b. Returns \(localEdge, true\) if found, or \(\-1, false\) if not found.


## func FlipEdge — `cdt/adjacency.go:132`

[FlipEdge](TriSoup.FlipEdge)func (ts *TriSoup) FlipEdge(tLeft TriID, eLeft int) (TriID, TriID, bool)
FlipEdge performs an edge flip on the shared edge between two triangles. Returns the two new triangle IDs and true if successful. Returns \(NilTri, NilTri, false\) if the flip cannot be performed.


## func IsDeleted — `cdt/adjacency.go:95`

[IsDeleted](TriSoup.IsDeleted)func (ts *TriSoup) IsDeleted(t TriID) bool
IsDeleted returns true if the triangle has been deleted.


## func RemoveTri — `cdt/adjacency.go:65`

[RemoveTri](TriSoup.RemoveTri)func (ts *TriSoup) RemoveTri(t TriID)
RemoveTri marks a triangle as deleted and unregisters its edges.


## func SetNeighbors — `cdt/adjacency.go:103`

[SetNeighbors](TriSoup.SetNeighbors)func (ts *TriSoup) SetNeighbors(t TriID, n0, n1, n2 TriID)
SetNeighbors sets all three neighbors of a triangle at once.


## func Validate — `cdt/adjacency.go:259`

[Validate](TriSoup.Validate)func (ts *TriSoup) Validate() error
Validate performs sanity checks on the triangulation.


# formatting

	import "github.com/iceisfun/gomesh/formatting"

## Index

- [func AABBString\(box types.AABB\) string](<#AABBString>)
- [func EdgeString\(e types.Edge\) string](<#EdgeString>)
- [func PointString\(p types.Point\) string](<#PointString>)
- [func PolygonLoopString\(loop types.PolygonLoop\) string](<#PolygonLoopString>)
- [func TriangleString\(t types.Triangle\) string](<#TriangleString>)
- [func VertexIDString\(id types.VertexID\) string](<#VertexIDString>)
- [func WriteAABB\(w io.Writer, box types.AABB\) error](<#WriteAABB>)
- [func WriteEdge\(w io.Writer, e types.Edge\) error](<#WriteEdge>)
- [func WritePoint\(w io.Writer, p types.Point\) error](<#WritePoint>)
- [func WritePolygonLoop\(w io.Writer, loop types.PolygonLoop\) error](<#WritePolygonLoop>)
- [func WriteTriangle\(w io.Writer, t types.Triangle\) error](<#WriteTriangle>)
- [func WriteVertexID\(w io.Writer, id types.VertexID\) error](<#WriteVertexID>)


## func AABBString — `formatting/aabb_stringer.go:11`

[AABBString](AABBString)func AABBString(box types.AABB) string
AABBString returns a concise string for an AABB.


## func EdgeString — `formatting/edge_stringer.go:11`

[EdgeString](EdgeString)func EdgeString(e types.Edge) string
EdgeString renders an edge in canonical form.


## func PointString — `formatting/point_stringer.go:11`

[PointString](PointString)func PointString(p types.Point) string
PointString returns a concise string representation of a point.


## func PolygonLoopString — `formatting/polygonloop_stringer.go:12`

[PolygonLoopString](PolygonLoopString)func PolygonLoopString(loop types.PolygonLoop) string
PolygonLoopString renders a polygon loop vertex list.


## func TriangleString — `formatting/triangle_stringer.go:11`

[TriangleString](TriangleString)func TriangleString(t types.Triangle) string
TriangleString renders a triangle's vertex IDs.


## func VertexIDString — `formatting/vertexid_stringer.go:11`

[VertexIDString](VertexIDString)func VertexIDString(id types.VertexID) string
VertexIDString renders a vertex ID for debugging.


## func WriteAABB — `formatting/aabb_stringer.go:16`

[WriteAABB](WriteAABB)func WriteAABB(w io.Writer, box types.AABB) error
WriteAABB writes a verbose representation of an AABB to a writer.


## func WriteEdge — `formatting/edge_stringer.go:16`

[WriteEdge](WriteEdge)func WriteEdge(w io.Writer, e types.Edge) error
WriteEdge writes an edge to a writer.


## func WritePoint — `formatting/point_stringer.go:16`

[WritePoint](WritePoint)func WritePoint(w io.Writer, p types.Point) error
WritePoint writes a verbose representation of a point to a writer.


## func WritePolygonLoop — `formatting/polygonloop_stringer.go:21`

[WritePolygonLoop](WritePolygonLoop)func WritePolygonLoop(w io.Writer, loop types.PolygonLoop) error
WritePolygonLoop writes a polygon loop representation to a writer.


## func WriteTriangle — `formatting/triangle_stringer.go:16`

[WriteTriangle](WriteTriangle)func WriteTriangle(w io.Writer, t types.Triangle) error
WriteTriangle writes a triangle to a writer.


## func WriteVertexID — `formatting/vertexid_stringer.go:16`

[WriteVertexID](WriteVertexID)func WriteVertexID(w io.Writer, id types.VertexID) error
WriteVertexID writes a vertex ID representation to a writer.


# intersections

	import "github.com/iceisfun/gomesh/intersections"

## Index

- [func MeshIntersectsAABB\(m \*mesh.Mesh, box types.AABB\) bool](<#MeshIntersectsAABB>)
- [func PointInMesh\(m \*mesh.Mesh, p types.Point\) bool](<#PointInMesh>)
- [func PolygonIntersectsAABB\(poly \[\]types.Point, box types.AABB, epsilon float64\) bool](<#PolygonIntersectsAABB>)
- [func SegmentIntersection\(m \*mesh.Mesh, a1, a2, b1, b2 types.VertexID\) \(types.Point, types.IntersectionType, error\)](<#SegmentIntersection>)
- [func TriangleIntersectsAABB\(m \*mesh.Mesh, triIndex int, box types.AABB\) \(bool, error\)](<#TriangleIntersectsAABB>)


## func MeshIntersectsAABB — `intersections/aabb.go:10`

[MeshIntersectsAABB](MeshIntersectsAABB)func MeshIntersectsAABB(m *mesh.Mesh, box types.AABB) bool
MeshIntersectsAABB tests if any triangle in the mesh intersects an AABB.


## func PointInMesh — `intersections/point.go:10`

[PointInMesh](PointInMesh)func PointInMesh(m *mesh.Mesh, p types.Point) bool
PointInMesh tests if a point is inside any triangle in the mesh.


## func PolygonIntersectsAABB — `intersections/polygon.go:9`

[PolygonIntersectsAABB](PolygonIntersectsAABB)func PolygonIntersectsAABB(poly []types.Point, box types.AABB, epsilon float64) bool
PolygonIntersectsAABB tests if a polygon intersects an AABB.


## func SegmentIntersection — `intersections/segment.go:10`

[SegmentIntersection](SegmentIntersection)func SegmentIntersection(m *mesh.Mesh, a1, a2, b1, b2 types.VertexID) (types.Point, types.IntersectionType, error)
SegmentIntersection computes the intersection of two segments by VertexID.


## func TriangleIntersectsAABB — `intersections/aabb.go:21`

[TriangleIntersectsAABB](TriangleIntersectsAABB)func TriangleIntersectsAABB(m *mesh.Mesh, triIndex int, box types.AABB) (bool, error)
TriangleIntersectsAABB tests if a specific triangle intersects an AABB.


# mesh

	import "github.com/iceisfun/gomesh/mesh"

## Index

- Constants
- Variables
- [type CandidateTriangle](<#CandidateTriangle>)
- [type CandidateVertex](<#CandidateVertex>)
- [type ErrTriangleOverlap](<#ErrTriangleOverlap>)
  - [func \(e ErrTriangleOverlap\) Error\(\) string](<#ErrTriangleOverlap.Error>)
- [type Mesh](<#Mesh>)
  - [func Load\(filename string\) \(\*Mesh, error\)](<#Load>)
  - [func NewMesh\(opts ...Option\) \*Mesh](<#NewMesh>)
  - [func \(m \*Mesh\) AddHole\(points \[\]types.Point\) \(types.PolygonLoop, error\)](<#Mesh.AddHole>)
  - [func \(m \*Mesh\) AddPerimeter\(points \[\]types.Point\) \(types.PolygonLoop, error\)](<#Mesh.AddPerimeter>)
  - [func \(m \*Mesh\) AddTriangle\(v1, v2, v3 types.VertexID\) error](<#Mesh.AddTriangle>)
  - [func \(m \*Mesh\) AddVertex\(p types.Point\) \(types.VertexID, error\)](<#Mesh.AddVertex>)
  - [func \(m \*Mesh\) EdgeSet\(\) map\[types.Edge\]struct\{\}](<#Mesh.EdgeSet>)
  - [func \(m \*Mesh\) EdgeUsageCounts\(\) map\[types.Edge\]int](<#Mesh.EdgeUsageCounts>)
  - [func \(m \*Mesh\) Epsilon\(\) float64](<#Mesh.Epsilon>)
  - [func \(m \*Mesh\) FindOverlappingTriangles\(\) \[\]TriangleOverlap](<#Mesh.FindOverlappingTriangles>)
  - [func \(m \*Mesh\) FindVertexNear\(p types.Point\) \(types.VertexID, bool\)](<#Mesh.FindVertexNear>)
  - [func \(m \*Mesh\) GenerateOverlapTestCase\(overlap TriangleOverlap\) \(\*OverlapTestCase, error\)](<#Mesh.GenerateOverlapTestCase>)
  - [func \(m \*Mesh\) GetHoles\(\) \[\]types.PolygonLoop](<#Mesh.GetHoles>)
  - [func \(m \*Mesh\) GetPerimeters\(\) \[\]types.PolygonLoop](<#Mesh.GetPerimeters>)
  - [func \(m \*Mesh\) GetTriangle\(idx int\) types.Triangle](<#Mesh.GetTriangle>)
  - [func \(m \*Mesh\) GetTriangleCoords\(idx int\) \(types.Point, types.Point, types.Point\)](<#Mesh.GetTriangleCoords>)
  - [func \(m \*Mesh\) GetTriangles\(\) \[\]types.Triangle](<#Mesh.GetTriangles>)
  - [func \(m \*Mesh\) GetUntriangulatedVertices\(loops \[\]types.PolygonLoop\) \[\]types.VertexID](<#Mesh.GetUntriangulatedVertices>)
  - [func \(m \*Mesh\) GetVertex\(id types.VertexID\) types.Point](<#Mesh.GetVertex>)
  - [func \(m \*Mesh\) GetVertices\(\) \[\]types.Point](<#Mesh.GetVertices>)
  - [func \(m \*Mesh\) HasTriangleWithKey\(key \[3\]types.VertexID\) \(types.Triangle, bool\)](<#Mesh.HasTriangleWithKey>)
  - [func \(m \*Mesh\) Holes\(\) \[\]types.PolygonLoop](<#Mesh.Holes>)
  - [func \(m \*Mesh\) IsValidVertexID\(id types.VertexID\) bool](<#Mesh.IsValidVertexID>)
  - [func \(m \*Mesh\) NumTriangles\(\) int](<#Mesh.NumTriangles>)
  - [func \(m \*Mesh\) NumVertices\(\) int](<#Mesh.NumVertices>)
  - [func \(m \*Mesh\) Perimeters\(\) \[\]types.PolygonLoop](<#Mesh.Perimeters>)
  - [func \(m \*Mesh\) Print\(w io.Writer\) error](<#Mesh.Print>)
  - [func \(m \*Mesh\) Save\(filename string\) error](<#Mesh.Save>)
  - [func \(m \*Mesh\) VertexFindCandidates\(v types.VertexID\) \[\]CandidateVertex](<#Mesh.VertexFindCandidates>)
  - [func \(m \*Mesh\) VertexFindTriangleCandidates\(v types.VertexID\) \[\]CandidateTriangle](<#Mesh.VertexFindTriangleCandidates>)
- [type MeshData](<#MeshData>)
- [type Option](<#Option>)
  - [func WithDebugAddEdge\(hook func\(types.Edge\)\) Option](<#WithDebugAddEdge>)
  - [func WithDebugAddTriangle\(hook func\(types.Triangle\)\) Option](<#WithDebugAddTriangle>)
  - [func WithDebugAddVertex\(hook func\(types.VertexID, types.Point\)\) Option](<#WithDebugAddVertex>)
  - [func WithDuplicateTriangleError\(enable bool\) Option](<#WithDuplicateTriangleError>)
  - [func WithDuplicateTriangleOpposingWinding\(enable bool\) Option](<#WithDuplicateTriangleOpposingWinding>)
  - [func WithEdgeCannotCrossPerimeter\(enable bool\) Option](<#WithEdgeCannotCrossPerimeter>)
  - [func WithEdgeIntersectionCheck\(enable bool\) Option](<#WithEdgeIntersectionCheck>)
  - [func WithEpsilon\(epsilon float64\) Option](<#WithEpsilon>)
  - [func WithMergeDistance\(distance float64\) Option](<#WithMergeDistance>)
  - [func WithMergeVertices\(enable bool\) Option](<#WithMergeVertices>)
  - [func WithOverlapTriangle\(allow bool\) Option](<#WithOverlapTriangle>)
  - [func WithTriangleEnforceNoVertexInside\(enable bool\) Option](<#WithTriangleEnforceNoVertexInside>)
  - [func WithTriangleOverlapCheck\(enable bool\) Option](<#WithTriangleOverlapCheck>)
- [type OverlapTestCase](<#OverlapTestCase>)
  - [func \(tc \*OverlapTestCase\) GenerateGoTestCode\(\) string](<#OverlapTestCase.GenerateGoTestCode>)
  - [func \(tc \*OverlapTestCase\) GenerateHumanReadableReport\(\) string](<#OverlapTestCase.GenerateHumanReadableReport>)
- [type SavedConfig](<#SavedConfig>)
- [type TriangleOverlap](<#TriangleOverlap>)


## Constants

<a name="DefaultEpsilon"></a>DefaultEpsilon is the default tolerance for geometric operations.

	const DefaultEpsilon = 1e-9

## Variables

<a name="ErrInvalidVertexID"></a>

	var (
	    // ErrInvalidVertexID indicates a vertex ID is out of range or negative.
	    ErrInvalidVertexID = errors.New("gomesh: invalid vertex id")
	
	    // ErrInvalidTriangleIndex indicates a triangle index is out of range.
	    ErrInvalidTriangleIndex = errors.New("gomesh: invalid triangle index")
	
	    // ErrDegenerateTriangle indicates triangle vertices are collinear.
	    ErrDegenerateTriangle = errors.New("gomesh: degenerate triangle (collinear)")
	
	    // ErrDuplicateTriangle indicates the same three vertices already exist.
	    ErrDuplicateTriangle = errors.New("gomesh: duplicate triangle (any winding)")
	
	    // ErrOpposingWindingDuplicate indicates the same three vertices exist with opposite winding direction.
	    ErrOpposingWindingDuplicate = errors.New("gomesh: duplicate triangle with opposing winding")
	
	    // ErrVertexInsideTriangle indicates an existing vertex lies strictly inside the triangle being added.
	    ErrVertexInsideTriangle = errors.New("gomesh: vertex lies inside triangle")
	
	    // ErrEdgeIntersection indicates a triangle edge would intersect an existing mesh edge.
	    ErrEdgeIntersection = errors.New("gomesh: edge intersection with existing mesh")
	
	    // ErrEdgeCrossesPerimeter indicates a triangle edge would cross a perimeter or hole boundary.
	    ErrEdgeCrossesPerimeter = errors.New("gomesh: edge crosses perimeter or hole boundary")
	)

<a name="CandidateTriangle"></a>
## type CandidateTriangle

CandidateTriangle represents a valid triangle that can be formed.

	type CandidateTriangle struct {
	    V1, V2, V3 types.VertexID
	    P1, P2, P3 types.Point
	}

<a name="CandidateVertex"></a>
## type CandidateVertex

CandidateVertex represents a vertex that can be connected to another vertex.

	type CandidateVertex struct {
	    VertexID types.VertexID
	    Point    types.Point
	}

<a name="ErrTriangleOverlap"></a>
## type ErrTriangleOverlap

ErrTriangleOverlap indicates a triangle would overlap with an existing triangle. This error includes details about which triangle it overlaps with and the intersection area.

	type ErrTriangleOverlap struct {
	    TriangleIndex    int
	    IntersectionArea float64
	}

## func Error — `mesh/errors.go:41`

[Error](ErrTriangleOverlap.Error)func (e ErrTriangleOverlap) Error() string



<a name="Mesh"></a>
## type Mesh

Mesh represents a 2D triangle mesh with validated topology.

	type Mesh struct {
	    // contains filtered or unexported fields
	}

## func Load — `mesh/save_load.go:76`

[Load](Load)func Load(filename string) (*Mesh, error)
Load reads a mesh state from a JSON file.

The loaded mesh will have the same configuration as the saved mesh, but debug hooks are not preserved.

Example:

	m, err := mesh.Load("problem_mesh.json")
	


## func NewMesh — `mesh/constructor.go:9`

[NewMesh](NewMesh)func NewMesh(opts ...Option) *Mesh
NewMesh creates a new empty mesh with the given options.


## func AddHole — `mesh/polygon_ops.go:72`

[AddHole](Mesh.AddHole)func (m *Mesh) AddHole(points []types.Point) (types.PolygonLoop, error)
AddHole adds a hole polygon inside a perimeter.

The hole must:

- Lie completely inside exactly one perimeter
- Not intersect with any existing perimeter or hole
- Not contain any other holes

Returns the PolygonLoop of vertex IDs, or an error if validation fails.

Example:

	holePoints := []types.Point{{2,2}, {8,2}, {8,8}, {2,8}}
	loop, err := m.AddHole(holePoints)
	


## func AddPerimeter — `mesh/polygon_ops.go:24`

[AddPerimeter](Mesh.AddPerimeter)func (m *Mesh) AddPerimeter(points []types.Point) (types.PolygonLoop, error)
AddPerimeter adds a perimeter polygon to the mesh.

The polygon is defined by a sequence of points forming a closed loop. Vertices are added to the mesh \(or merged if merging is enabled\) and the polygon loop is tracked for hole validation.

If edge intersection checking is enabled, overlapping perimeters will be rejected.

Returns the PolygonLoop of vertex IDs, or an error if validation fails.

Example:

	points := []types.Point{{0,0}, {10,0}, {10,10}, {0,10}}
	loop, err := m.AddPerimeter(points)
	


## func AddTriangle — `mesh/triangle_ops.go:12`

[AddTriangle](Mesh.AddTriangle)func (m *Mesh) AddTriangle(v1, v2, v3 types.VertexID) error
AddTriangle adds a triangle to the mesh with validation.


## func AddVertex — `mesh/vertex_ops.go:10`

[AddVertex](Mesh.AddVertex)func (m *Mesh) AddVertex(p types.Point) (types.VertexID, error)
AddVertex adds a vertex to the mesh or returns an existing nearby vertex.


## func EdgeSet — `mesh/mesh.go:86`

[EdgeSet](Mesh.EdgeSet)func (m *Mesh) EdgeSet() map[types.Edge]struct{}
EdgeSet exposes the set of edges currently tracked by the mesh.


## func EdgeUsageCounts — `mesh/mesh.go:99`

[EdgeUsageCounts](Mesh.EdgeUsageCounts)func (m *Mesh) EdgeUsageCounts() map[types.Edge]int
EdgeUsageCounts returns a map of each edge to the number of triangles using it.

In a valid triangulation, each edge should be used by at most 2 triangles.


## func Epsilon — `mesh/mesh.go:81`

[Epsilon](Mesh.Epsilon)func (m *Mesh) Epsilon() float64
Epsilon returns the configured epsilon tolerance.


## func FindOverlappingTriangles — `mesh/overlap.go:25`

[FindOverlappingTriangles](Mesh.FindOverlappingTriangles)func (m *Mesh) FindOverlappingTriangles() []TriangleOverlap
FindOverlappingTriangles checks all pairs of triangles for geometric overlap. This is an O\(n²\) operation and should be used for validation/debugging only. Only returns overlaps with non\-zero intersection area \(true volumetric overlaps\).


## func FindVertexNear — `mesh/vertex_ops.go:46`

[FindVertexNear](Mesh.FindVertexNear)func (m *Mesh) FindVertexNear(p types.Point) (types.VertexID, bool)
FindVertexNear searches for a vertex within merge distance of p.


## func GenerateOverlapTestCase — `mesh/overlap_test_generator.go:25`

[GenerateOverlapTestCase](Mesh.GenerateOverlapTestCase)func (m *Mesh) GenerateOverlapTestCase(overlap TriangleOverlap) (*OverlapTestCase, error)
GenerateOverlapTestCase creates a minimal test mesh from an overlap. Returns a test case that can be used to verify overlap detection.


## func GetHoles — `mesh/polygon_ops.go:310`

[GetHoles](Mesh.GetHoles)func (m *Mesh) GetHoles() []types.PolygonLoop
GetHoles returns all hole loops


## func GetPerimeters — `mesh/polygon_ops.go:303`

[GetPerimeters](Mesh.GetPerimeters)func (m *Mesh) GetPerimeters() []types.PolygonLoop
GetPerimeters returns all perimeter loops


## func GetTriangle — `mesh/mesh.go:51`

[GetTriangle](Mesh.GetTriangle)func (m *Mesh) GetTriangle(idx int) types.Triangle
GetTriangle returns a triangle by index.


## func GetTriangleCoords — `mesh/mesh.go:70`

[GetTriangleCoords](Mesh.GetTriangleCoords)func (m *Mesh) GetTriangleCoords(idx int) (types.Point, types.Point, types.Point)
GetTriangleCoords returns the coordinates of a triangle's vertices.


## func GetTriangles — `mesh/mesh.go:63`

[GetTriangles](Mesh.GetTriangles)func (m *Mesh) GetTriangles() []types.Triangle
GetTriangles returns a copy of all triangles.


## func GetUntriangulatedVertices — `mesh/mesh.go:121`

[GetUntriangulatedVertices](Mesh.GetUntriangulatedVertices)func (m *Mesh) GetUntriangulatedVertices(loops []types.PolygonLoop) []types.VertexID
GetUntriangulatedVertices returns vertices from the given loops that are not part of any triangle.

This is useful for identifying areas with missing triangulation during debugging.

Example:

	loops := []types.PolygonLoop{perimeter, hole1, hole2}
	untriangulated := m.GetUntriangulatedVertices(loops)
	if len(untriangulated) > 0 {
	    fmt.Printf("Found %d untriangulated vertices\n", len(untriangulated))
	}
	


## func GetVertex — `mesh/mesh.go:46`

[GetVertex](Mesh.GetVertex)func (m *Mesh) GetVertex(id types.VertexID) types.Point
GetVertex returns the coordinates of a vertex by ID.


## func GetVertices — `mesh/mesh.go:56`

[GetVertices](Mesh.GetVertices)func (m *Mesh) GetVertices() []types.Point
GetVertices returns a copy of all vertex coordinates.


## func HasTriangleWithKey — `mesh/mesh.go:91`

[HasTriangleWithKey](Mesh.HasTriangleWithKey)func (m *Mesh) HasTriangleWithKey(key [3]types.VertexID) (types.Triangle, bool)
HasTriangleWithKey reports whether the canonical key is present.


## func Holes — `mesh/mesh.go:41`

[Holes](Mesh.Holes)func (m *Mesh) Holes() []types.PolygonLoop
Holes returns the list of hole loops.


## func IsValidVertexID — `mesh/mesh.go:76`

[IsValidVertexID](Mesh.IsValidVertexID)func (m *Mesh) IsValidVertexID(id types.VertexID) bool
IsValidVertexID reports whether the supplied ID references an existing vertex.


## func NumTriangles — `mesh/mesh.go:31`

[NumTriangles](Mesh.NumTriangles)func (m *Mesh) NumTriangles() int
NumTriangles returns the number of triangles in the mesh.


## func NumVertices — `mesh/mesh.go:26`

[NumVertices](Mesh.NumVertices)func (m *Mesh) NumVertices() int
NumVertices returns the number of vertices in the mesh.


## func Perimeters — `mesh/mesh.go:36`

[Perimeters](Mesh.Perimeters)func (m *Mesh) Perimeters() []types.PolygonLoop
Perimeters returns the list of perimeter loops.


## func Print — `mesh/print.go:21`

[Print](Mesh.Print)func (m *Mesh) Print(w io.Writer) error
Print writes a detailed representation of the mesh to the writer.

The output includes:

- Number of vertices, triangles, perimeters, and holes
- All vertex coordinates
- All triangles
- All perimeter loops
- All hole loops

Example:

	m.Print(os.Stdout)
	


## func Save — `mesh/save_load.go:39`

[Save](Mesh.Save)func (m *Mesh) Save(filename string) error
Save writes the mesh state to a JSON file.

This is useful for debugging \- you can capture a problematic mesh state and share it for analysis.

Example:

	m.Save("problem_mesh.json")
	


## func VertexFindCandidates — `mesh/candidates.go:35`

[VertexFindCandidates](Mesh.VertexFindCandidates)func (m *Mesh) VertexFindCandidates(v types.VertexID) []CandidateVertex
VertexFindCandidates finds all valid vertices that the given vertex can connect to without crossing a perimeter, hole, or existing triangle edge.

This is a computationally expensive exhaustive search intended for debugging triangulation algorithms that get stuck.

Uses goroutines for parallel search.

Example:

	candidates := m.VertexFindCandidates(v0)
	fmt.Printf("Vertex %d can connect to %d vertices\n", v0, len(candidates))
	


## func VertexFindTriangleCandidates — `mesh/candidates.go:127`

[VertexFindTriangleCandidates](Mesh.VertexFindTriangleCandidates)func (m *Mesh) VertexFindTriangleCandidates(v types.VertexID) []CandidateTriangle
VertexFindTriangleCandidates finds all valid triangles that can be formed with the given vertex without violating mesh rules.

This is a computationally expensive exhaustive search intended for debugging triangulation algorithms that get stuck.

Checks all constraints:

- No degenerate triangles
- No duplicate triangles \(if enabled\)
- No vertex inside triangle \(if enabled\)
- No edge intersections \(if enabled\)
- No perimeter/hole crossing \(if enabled\)

Uses goroutines for parallel search.

Example:

	candidates := m.VertexFindTriangleCandidates(v0)
	fmt.Printf("Vertex %d can form %d triangles\n", v0, len(candidates))
	for _, tri := range candidates {
	    fmt.Printf("  Triangle: %d-%d-%d\n", tri.V1, tri.V2, tri.V3)
	}
	


<a name="MeshData"></a>
## type MeshData

MeshData represents the serializable state of a mesh.

	type MeshData struct {
	    Vertices   []types.Point       `json:"vertices"`
	    Perimeters []types.PolygonLoop `json:"perimeters"`
	    Holes      []types.PolygonLoop `json:"holes"`
	    Triangles  []types.Triangle    `json:"triangles"`
	    Config     SavedConfig         `json:"config"`
	}

<a name="Option"></a>
## type Option

Option configures a Mesh during construction.

	type Option func(*config)

## func WithDebugAddEdge — `mesh/options.go:118`

[WithDebugAddEdge](WithDebugAddEdge)func WithDebugAddEdge(hook func(types.Edge)) Option
WithDebugAddEdge installs a hook called after a new edge is recorded.


## func WithDebugAddTriangle — `mesh/options.go:125`

[WithDebugAddTriangle](WithDebugAddTriangle)func WithDebugAddTriangle(hook func(types.Triangle)) Option
WithDebugAddTriangle installs a hook called after triangle insertion.


## func WithDebugAddVertex — `mesh/options.go:111`

[WithDebugAddVertex](WithDebugAddVertex)func WithDebugAddVertex(hook func(types.VertexID, types.Point)) Option
WithDebugAddVertex installs a hook called after vertex insertion.


## func WithDuplicateTriangleError — `mesh/options.go:72`

[WithDuplicateTriangleError](WithDuplicateTriangleError)func WithDuplicateTriangleError(enable bool) Option
WithDuplicateTriangleError rejects triangles with duplicate vertex sets.


## func WithDuplicateTriangleOpposingWinding — `mesh/options.go:79`

[WithDuplicateTriangleOpposingWinding](WithDuplicateTriangleOpposingWinding)func WithDuplicateTriangleOpposingWinding(enable bool) Option
WithDuplicateTriangleOpposingWinding rejects triangles with opposing winding.


## func WithEdgeCannotCrossPerimeter — `mesh/options.go:65`

[WithEdgeCannotCrossPerimeter](WithEdgeCannotCrossPerimeter)func WithEdgeCannotCrossPerimeter(enable bool) Option
WithEdgeCannotCrossPerimeter prevents triangle edges from crossing perimeter or hole boundaries.

When enabled, triangle edges cannot intersect perimeter or hole edge segments. However, edges that land exactly on a perimeter/hole edge are allowed.

This is useful for constrained triangulation where triangles must not cross the boundary polygons.


## func WithEdgeIntersectionCheck — `mesh/options.go:43`

[WithEdgeIntersectionCheck](WithEdgeIntersectionCheck)func WithEdgeIntersectionCheck(enable bool) Option
WithEdgeIntersectionCheck enables edge intersection validation.


## func WithEpsilon — `mesh/options.go:9`

[WithEpsilon](WithEpsilon)func WithEpsilon(epsilon float64) Option
WithEpsilon sets the geometric tolerance for the mesh.


## func WithMergeDistance — `mesh/options.go:26`

[WithMergeDistance](WithMergeDistance)func WithMergeDistance(distance float64) Option
WithMergeDistance sets the radius for vertex merging.


## func WithMergeVertices — `mesh/options.go:19`

[WithMergeVertices](WithMergeVertices)func WithMergeVertices(enable bool) Option
WithMergeVertices enables or disables automatic vertex merging.


## func WithOverlapTriangle — `mesh/options.go:102`

[WithOverlapTriangle](WithOverlapTriangle)func WithOverlapTriangle(allow bool) Option
WithOverlapTriangle controls whether overlapping/duplicate triangles are allowed.

When set to false, adding the same triangle with different vertex orders \(e.g., 9,0,1 and 1,0,9\) will return ErrDuplicateTriangle.

When set to true \(default\), overlapping triangles are allowed and will be added to the mesh multiple times.

Example:

	m := NewMesh(WithOverlapTriangle(false))  // Prohibit overlaps
	m.AddTriangle(0, 1, 2)  // OK
	m.AddTriangle(1, 2, 0)  // Error: ErrDuplicateTriangle
	
	m2 := NewMesh(WithOverlapTriangle(true))  // Allow overlaps (default)
	m2.AddTriangle(0, 1, 2)  // OK
	m2.AddTriangle(1, 2, 0)  // OK - adds duplicate
	


## func WithTriangleEnforceNoVertexInside — `mesh/options.go:36`

[WithTriangleEnforceNoVertexInside](WithTriangleEnforceNoVertexInside)func WithTriangleEnforceNoVertexInside(enable bool) Option
WithTriangleEnforceNoVertexInside enables vertex\-inside validation.


## func WithTriangleOverlapCheck — `mesh/options.go:52`

[WithTriangleOverlapCheck](WithTriangleOverlapCheck)func WithTriangleOverlapCheck(enable bool) Option
WithTriangleOverlapCheck enables volumetric triangle overlap validation. This performs geometric intersection area calculations to detect overlapping triangles. This is more expensive than other validation checks but catches all overlap cases.


<a name="OverlapTestCase"></a>
## type OverlapTestCase

OverlapTestCase represents a minimal test case for reproducing an overlap.

	type OverlapTestCase struct {
	    Name             string
	    Vertices         []types.Point
	    Triangle1        types.Triangle // Using original vertex IDs
	    Triangle2        types.Triangle
	    Triangle1New     types.Triangle // Using remapped vertex IDs
	    Triangle2New     types.Triangle
	    ExpectedError    bool
	    ActualError      error
	    IntersectionArea float64
	}

## func GenerateGoTestCode — `mesh/overlap_test_generator.go:97`

[GenerateGoTestCode](OverlapTestCase.GenerateGoTestCode)func (tc *OverlapTestCase) GenerateGoTestCode() string
GenerateGoTestCode generates Go test code for the overlap test case.


## func GenerateHumanReadableReport — `mesh/overlap_test_generator.go:143`

[GenerateHumanReadableReport](OverlapTestCase.GenerateHumanReadableReport)func (tc *OverlapTestCase) GenerateHumanReadableReport() string
GenerateHumanReadableReport generates a human\-readable report of the test case.


<a name="SavedConfig"></a>
## type SavedConfig

SavedConfig captures the mesh configuration for reconstruction.

	type SavedConfig struct {
	    Epsilon                          float64 `json:"epsilon"`
	    MergeVertices                    bool    `json:"merge_vertices"`
	    MergeDistance                    float64 `json:"merge_distance"`
	    ValidateVertexInside             bool    `json:"validate_vertex_inside"`
	    ValidateEdgeIntersection         bool    `json:"validate_edge_intersection"`
	    ValidateEdgeCannotCrossPerimeter bool    `json:"validate_edge_cannot_cross_perimeter"`
	    ErrorOnDuplicateTriangle         bool    `json:"error_on_duplicate_triangle"`
	    ErrorOnOpposingDuplicate         bool    `json:"error_on_opposing_duplicate"`
	}

<a name="TriangleOverlap"></a>
## type TriangleOverlap

TriangleOverlap describes an overlapping pair of triangles.

	type TriangleOverlap struct {
	    Tri1             types.Triangle
	    Tri2             types.Triangle
	    Index1           int
	    Index2           int
	    Type             string
	    SharedVerts      int
	    SharedEdges      int
	    IntersectionArea float64
	}

# predicates

	import "github.com/iceisfun/gomesh/predicates"

## Index

- [func Area2\(a, b, c types.Point\) float64](<#Area2>)
- [func Dist2\(a, b types.Point\) float64](<#Dist2>)
- [func Orient\(a, b, c types.Point, eps float64\) int](<#Orient>)
- [func PointInAABB\(p types.Point, box types.AABB, eps float64\) bool](<#PointInAABB>)
- [func PointInPolygonRayCast\(p types.Point, poly \[\]types.Point, eps float64\) bool](<#PointInPolygonRayCast>)
- [func PointInTriangle\(p, a, b, c types.Point, eps float64\) bool](<#PointInTriangle>)
- [func PointOnSegment\(p, a, b types.Point, eps float64\) bool](<#PointOnSegment>)
- [func PointStrictlyInTriangle\(p, a, b, c types.Point, eps float64\) bool](<#PointStrictlyInTriangle>)
- [func PolygonAABBIntersect\(poly \[\]types.Point, box types.AABB, eps float64\) bool](<#PolygonAABBIntersect>)
- [func PolygonArea\(poly \[\]types.Point\) float64](<#PolygonArea>)
- [func PolygonBounds\(poly \[\]types.Point\) types.AABB](<#PolygonBounds>)
- [func PolygonContainsPolygon\(a, b \[\]types.Point, eps float64\) bool](<#PolygonContainsPolygon>)
- [func PolygonLoopArea\(vp types.VertexProvider, loop types.PolygonLoop\) float64](<#PolygonLoopArea>)
- [func PolygonLoopBounds\(vp types.VertexProvider, loop types.PolygonLoop\) types.AABB](<#PolygonLoopBounds>)
- [func PolygonLoopContains\(vp types.VertexProvider, loop types.PolygonLoop, point types.Point, eps float64\) bool](<#PolygonLoopContains>)
- [func PolygonLoopContainsPolygonLoop\(vp types.VertexProvider, a, b types.PolygonLoop, eps float64\) bool](<#PolygonLoopContainsPolygonLoop>)
- [func PolygonLoopSelfIntersects\(vp types.VertexProvider, loop types.PolygonLoop, eps float64\) bool](<#PolygonLoopSelfIntersects>)
- [func PolygonLoopsIntersect\(vp types.VertexProvider, a, b types.PolygonLoop, eps float64\) bool](<#PolygonLoopsIntersect>)
- [func PolygonSelfIntersects\(poly \[\]types.Point, eps float64\) bool](<#PolygonSelfIntersects>)
- [func PolygonsIntersect\(a, b \[\]types.Point, eps float64\) bool](<#PolygonsIntersect>)
- [func SegmentAABBIntersect\(a, b types.Point, box types.AABB, eps float64\) bool](<#SegmentAABBIntersect>)
- [func SegmentIntersectionPoint\(a1, a2, b1, b2 types.Point, eps float64\) \(types.Point, types.IntersectionType\)](<#SegmentIntersectionPoint>)
- [func SegmentsIntersect\(a1, a2, b1, b2 types.Point, eps float64\) \(bool, bool\)](<#SegmentsIntersect>)
- [func TriangleAABBIntersect\(a, b, c types.Point, box types.AABB, eps float64\) bool](<#TriangleAABBIntersect>)
- [func TriangleIntersectionArea\(a1, a2, a3, b1, b2, b3 types.Point, eps float64\) float64](<#TriangleIntersectionArea>)
- [func TriangleIntersectionPolygon\(a1, a2, a3, b1, b2, b3 types.Point, eps float64\) \[\]types.Point](<#TriangleIntersectionPolygon>)


## func Area2 — `predicates/triangle.go:10`

[Area2](Area2)func Area2(a, b, c types.Point) float64
Area2 computes twice the signed area of a triangle.


## func Dist2 — `predicates/segment.go:10`

[Dist2](Dist2)func Dist2(a, b types.Point) float64
Dist2 returns the squared Euclidean distance between two points.


## func Orient — `predicates/triangle.go:15`

[Orient](Orient)func Orient(a, b, c types.Point, eps float64) int
Orient determines the orientation of three points with tolerance.


## func PointInAABB — `predicates/aabb.go:10`

[PointInAABB](PointInAABB)func PointInAABB(p types.Point, box types.AABB, eps float64) bool
PointInAABB tests if a point is inside or on an AABB.


## func PointInPolygonRayCast — `predicates/polygon.go:6`

[PointInPolygonRayCast](PointInPolygonRayCast)func PointInPolygonRayCast(p types.Point, poly []types.Point, eps float64) bool
PointInPolygonRayCast tests if a point is inside a polygon using ray casting.


## func PointInTriangle — `predicates/triangle.go:27`

[PointInTriangle](PointInTriangle)func PointInTriangle(p, a, b, c types.Point, eps float64) bool
PointInTriangle tests if a point is inside or on a triangle.


## func PointOnSegment — `predicates/segment.go:84`

[PointOnSegment](PointOnSegment)func PointOnSegment(p, a, b types.Point, eps float64) bool
PointOnSegment tests if a point lies on a line segment within tolerance.


## func PointStrictlyInTriangle — `predicates/triangle.go:44`

[PointStrictlyInTriangle](PointStrictlyInTriangle)func PointStrictlyInTriangle(p, a, b, c types.Point, eps float64) bool
PointStrictlyInTriangle tests if a point lies strictly inside a triangle.


## func PolygonAABBIntersect — `predicates/polygon.go:210`

[PolygonAABBIntersect](PolygonAABBIntersect)func PolygonAABBIntersect(poly []types.Point, box types.AABB, eps float64) bool
PolygonAABBIntersect tests if a polygon intersects an AABB.


## func PolygonArea — `predicates/polygon.go:164`

[PolygonArea](PolygonArea)func PolygonArea(poly []types.Point) float64
PolygonArea computes the signed area of a polygon.

Returns:

- Positive area for CCW \(counter\-clockwise\) winding
- Negative area for CW \(clockwise\) winding
- Zero for degenerate polygons


## func PolygonBounds — `predicates/polygon.go:181`

[PolygonBounds](PolygonBounds)func PolygonBounds(poly []types.Point) types.AABB
PolygonBounds computes the axis\-aligned bounding box of a polygon.


## func PolygonContainsPolygon — `predicates/polygon.go:78`

[PolygonContainsPolygon](PolygonContainsPolygon)func PolygonContainsPolygon(a, b []types.Point, eps float64) bool
PolygonContainsPolygon tests if polygon A completely contains polygon B.

Returns true if all vertices of B are inside A and no edges of B intersect edges of A.


## func PolygonLoopArea — `predicates/polygon.go:304`

[PolygonLoopArea](PolygonLoopArea)func PolygonLoopArea(vp types.VertexProvider, loop types.PolygonLoop) float64
PolygonLoopArea computes the signed area of a polygon loop.

Example:

	area := PolygonLoopArea(mesh, loop)
	


## func PolygonLoopBounds — `predicates/polygon.go:314`

[PolygonLoopBounds](PolygonLoopBounds)func PolygonLoopBounds(vp types.VertexProvider, loop types.PolygonLoop) types.AABB
PolygonLoopBounds computes the bounding box of a polygon loop.

Example:

	bounds := PolygonLoopBounds(mesh, loop)
	


## func PolygonLoopContains — `predicates/polygon.go:268`

[PolygonLoopContains](PolygonLoopContains)func PolygonLoopContains(vp types.VertexProvider, loop types.PolygonLoop, point types.Point, eps float64) bool
PolygonLoopContains tests if a point is inside a polygon loop.

Example:

	if PolygonLoopContains(mesh, loop, point, 1e-9) {
	    // Point is inside
	}
	


## func PolygonLoopContainsPolygonLoop — `predicates/polygon.go:280`

[PolygonLoopContainsPolygonLoop](PolygonLoopContainsPolygonLoop)func PolygonLoopContainsPolygonLoop(vp types.VertexProvider, a, b types.PolygonLoop, eps float64) bool
PolygonLoopContainsPolygonLoop tests if polygon loop A contains loop B.

Example:

	if PolygonLoopContainsPolygonLoop(mesh, outer, inner, 1e-9) {
	    // Outer contains inner
	}
	


## func PolygonLoopSelfIntersects — `predicates/polygon.go:256`

[PolygonLoopSelfIntersects](PolygonLoopSelfIntersects)func PolygonLoopSelfIntersects(vp types.VertexProvider, loop types.PolygonLoop, eps float64) bool
PolygonLoopSelfIntersects checks if a polygon loop has self\-intersections.

The vertex provider \(e.g., mesh\) is used to resolve vertex coordinates.

Example:

	if PolygonLoopSelfIntersects(mesh, loop, 1e-9) {
	    // Handle self-intersection
	}
	


## func PolygonLoopsIntersect — `predicates/polygon.go:293`

[PolygonLoopsIntersect](PolygonLoopsIntersect)func PolygonLoopsIntersect(vp types.VertexProvider, a, b types.PolygonLoop, eps float64) bool
PolygonLoopsIntersect tests if two polygon loops intersect.

Example:

	if PolygonLoopsIntersect(mesh, loop1, loop2, 1e-9) {
	    // Loops intersect
	}
	


## func PolygonSelfIntersects — `predicates/polygon.go:41`

[PolygonSelfIntersects](PolygonSelfIntersects)func PolygonSelfIntersects(poly []types.Point, eps float64) bool
PolygonSelfIntersects checks if a polygon has any self\-intersections.

Returns true if any non\-adjacent edges intersect. Adjacent edges \(sharing a vertex\) are allowed to touch.


## func PolygonsIntersect — `predicates/polygon.go:118`

[PolygonsIntersect](PolygonsIntersect)func PolygonsIntersect(a, b []types.Point, eps float64) bool
PolygonsIntersect tests if two polygons intersect \(overlap or touch\).

Returns true if:

- Any vertex of one polygon is inside the other
- Any edges intersect
- One polygon contains the other


## func SegmentAABBIntersect — `predicates/aabb.go:20`

[SegmentAABBIntersect](SegmentAABBIntersect)func SegmentAABBIntersect(a, b types.Point, box types.AABB, eps float64) bool
SegmentAABBIntersect tests if a line segment intersects an AABB.


## func SegmentIntersectionPoint — `predicates/segment.go:46`

[SegmentIntersectionPoint](SegmentIntersectionPoint)func SegmentIntersectionPoint(a1, a2, b1, b2 types.Point, eps float64) (types.Point, types.IntersectionType)
SegmentIntersectionPoint computes the intersection point of two segments.


## func SegmentsIntersect — `predicates/segment.go:17`

[SegmentsIntersect](SegmentsIntersect)func SegmentsIntersect(a1, a2, b1, b2 types.Point, eps float64) (bool, bool)
SegmentsIntersect tests if two line segments intersect.


## func TriangleAABBIntersect — `predicates/aabb.go:64`

[TriangleAABBIntersect](TriangleAABBIntersect)func TriangleAABBIntersect(a, b, c types.Point, box types.AABB, eps float64) bool
TriangleAABBIntersect tests if a triangle intersects an AABB.


## func TriangleIntersectionArea — `predicates/triangle_intersection.go:11`

[TriangleIntersectionArea](TriangleIntersectionArea)func TriangleIntersectionArea(a1, a2, a3, b1, b2, b3 types.Point, eps float64) float64
TriangleIntersectionArea computes the area of intersection between two triangles. Returns 0 if they don't intersect.


## func TriangleIntersectionPolygon — `predicates/triangle_intersection.go:23`

[TriangleIntersectionPolygon](TriangleIntersectionPolygon)func TriangleIntersectionPolygon(a1, a2, a3, b1, b2, b3 types.Point, eps float64) []types.Point
TriangleIntersectionPolygon computes the polygon formed by the intersection of two triangles. Uses Sutherland\-Hodgman polygon clipping algorithm. Returns empty slice if triangles don't intersect.


# rasterize

	import "github.com/iceisfun/gomesh/rasterize"

## Index

- [func AlphaBlend\(dst, src color.Color\) color.RGBA](<#AlphaBlend>)
- [func DrawCircleAlpha\(img \*image.RGBA, centerX, centerY, radius int, col color.Color\)](<#DrawCircleAlpha>)
- [func DrawLineAlpha\(img \*image.RGBA, x0, y0, x1, y1 int, col color.Color\)](<#DrawLineAlpha>)
- [func DrawLineThickAlpha\(img \*image.RGBA, x0, y0, x1, y1 int, col color.Color, thickness int\)](<#DrawLineThickAlpha>)
- [func DrawPointAlpha\(img \*image.RGBA, x, y int, col color.Color\)](<#DrawPointAlpha>)
- [func FillTriangleAlpha\(img \*image.RGBA, ax, ay, bx, by, cx, cy int, col color.Color\)](<#FillTriangleAlpha>)
- [func Rasterize\(m \*mesh.Mesh, opts ...Option\) \(\*image.RGBA, error\)](<#Rasterize>)
- [func SetPixelAlpha\(img \*image.RGBA, x, y int, col color.Color\)](<#SetPixelAlpha>)
- [type Config](<#Config>)
  - [func DefaultConfig\(\) Config](<#DefaultConfig>)
- [type DebugElement](<#DebugElement>)
- [type DebugLocation](<#DebugLocation>)
- [type Option](<#Option>)
  - [func WithColors\(perimeter, hole, triangle, edge, vertex color.Color\) Option](<#WithColors>)
  - [func WithDebugElement\(name string, sourceX, sourceY, targetX, targetY float64\) Option](<#WithDebugElement>)
  - [func WithDebugLine\(name string, sourceX, sourceY, targetX, targetY float64\) Option](<#WithDebugLine>)
  - [func WithDebugLocation\(name string, x, y float64\) Option](<#WithDebugLocation>)
  - [func WithDimensions\(width, height int\) Option](<#WithDimensions>)
  - [func WithDrawEdges\(enable bool\) Option](<#WithDrawEdges>)
  - [func WithDrawHoles\(enable bool\) Option](<#WithDrawHoles>)
  - [func WithDrawPerimeters\(enable bool\) Option](<#WithDrawPerimeters>)
  - [func WithDrawVertices\(enable bool\) Option](<#WithDrawVertices>)
  - [func WithEdgeLabels\(enable bool\) Option](<#WithEdgeLabels>)
  - [func WithFillTriangles\(enable bool\) Option](<#WithFillTriangles>)
  - [func WithTriangleLabels\(enable bool\) Option](<#WithTriangleLabels>)
  - [func WithVertexLabels\(enable bool\) Option](<#WithVertexLabels>)
- [type Palette](<#Palette>)
  - [func HolePalette\(\) \*Palette](<#HolePalette>)
  - [func NewPalette\(\) \*Palette](<#NewPalette>)
  - [func NewTransparentPalette\(alpha uint8\) \*Palette](<#NewTransparentPalette>)
  - [func PerimeterPalette\(\) \*Palette](<#PerimeterPalette>)
  - [func TrianglePalette\(\) \*Palette](<#TrianglePalette>)
  - [func \(p \*Palette\) Get\(index int\) color.RGBA](<#Palette.Get>)
  - [func \(p \*Palette\) Next\(\) color.RGBA](<#Palette.Next>)
  - [func \(p \*Palette\) Reset\(\)](<#Palette.Reset>)
  - [func \(p \*Palette\) Size\(\) int](<#Palette.Size>)
  - [func \(p \*Palette\) WithAlpha\(alpha uint8\) \*Palette](<#Palette.WithAlpha>)
- [type Transform](<#Transform>)
  - [func \(t Transform\) Apply\(p types.Point\) \(int, int\)](<#Transform.Apply>)


## func AlphaBlend — `rasterize/alpha.go:14`

[AlphaBlend](AlphaBlend)func AlphaBlend(dst, src color.Color) color.RGBA
AlphaBlend performs alpha compositing of src over dst.

This implements the standard "over" operation:

	result = src + dst * (1 - src.alpha)
	

The source color is composited over the destination color.


## func DrawCircleAlpha — `rasterize/alpha.go:190`

[DrawCircleAlpha](DrawCircleAlpha)func DrawCircleAlpha(img *image.RGBA, centerX, centerY, radius int, col color.Color)
DrawCircleAlpha draws a circle outline with alpha blending.

Uses the midpoint circle algorithm \(Bresenham's circle algorithm\).


## func DrawLineAlpha — `rasterize/alpha.go:98`

[DrawLineAlpha](DrawLineAlpha)func DrawLineAlpha(img *image.RGBA, x0, y0, x1, y1 int, col color.Color)
DrawLineAlpha draws a line with alpha blending.


## func DrawLineThickAlpha — `rasterize/alpha.go:141`

[DrawLineThickAlpha](DrawLineThickAlpha)func DrawLineThickAlpha(img *image.RGBA, x0, y0, x1, y1 int, col color.Color, thickness int)
DrawLineThickAlpha draws a thick line with alpha blending.

The thickness parameter specifies the line width in pixels.


## func DrawPointAlpha — `rasterize/alpha.go:130`

[DrawPointAlpha](DrawPointAlpha)func DrawPointAlpha(img *image.RGBA, x, y int, col color.Color)
DrawPointAlpha draws a point \(3x3 square\) with alpha blending.


## func FillTriangleAlpha — `rasterize/alpha.go:72`

[FillTriangleAlpha](FillTriangleAlpha)func FillTriangleAlpha(img *image.RGBA, ax, ay, bx, by, cx, cy int, col color.Color)
FillTriangleAlpha fills a triangle with alpha blending.

Each pixel inside the triangle is composited over the existing pixel values using alpha blending.


## func Rasterize — `rasterize/rasterize.go:13`

[Rasterize](Rasterize)func Rasterize(m *mesh.Mesh, opts ...Option) (*image.RGBA, error)
Rasterize renders a mesh to an RGBA image.


## func SetPixelAlpha — `rasterize/alpha.go:57`

[SetPixelAlpha](SetPixelAlpha)func SetPixelAlpha(img *image.RGBA, x, y int, col color.Color)
SetPixelAlpha sets a pixel with alpha blending.

The color is composited over the existing pixel value using alpha blending.


<a name="Config"></a>
## type Config

Config holds options for rasterizing a mesh to an image.

	type Config struct {
	    Width  int
	    Height int
	
	    Background     color.Color
	    VertexColor    color.Color
	    EdgeColor      color.Color
	    TriangleColor  color.Color
	    PerimeterColor color.Color
	    HoleColor      color.Color
	
	    DebugElements  []DebugElement
	    DebugLocations []DebugLocation
	
	    FillTriangles  bool
	    DrawVertices   bool
	    DrawEdges      bool
	    DrawPerimeters bool
	    DrawHoles      bool
	
	    VertexLabels   bool
	    EdgeLabels     bool
	    TriangleLabels bool
	}

## func DefaultConfig — `rasterize/config.go:50`

[DefaultConfig](DefaultConfig)func DefaultConfig() Config
DefaultConfig returns sensible default rasterization settings.


<a name="DebugElement"></a>
## type DebugElement

DebugElement represents a debug line with a label. Coordinates are in mesh space and will be transformed to image coordinates.

	type DebugElement struct {
	    Name    string
	    SourceX float64
	    SourceY float64
	    TargetX float64
	    TargetY float64
	}

<a name="DebugLocation"></a>
## type DebugLocation

DebugLocation represents a debug point location with a label. Coordinates are in mesh space and will be transformed to image coordinates.

	type DebugLocation struct {
	    Name string
	    X    float64
	    Y    float64
	}

<a name="Option"></a>
## type Option

Option configures rasterization.

	type Option func(*Config)

## func WithColors — `rasterize/options.go:77`

[WithColors](WithColors)func WithColors(perimeter, hole, triangle, edge, vertex color.Color) Option
WithColors sets all colors at once.


## func WithDebugElement — `rasterize/options.go:124`

[WithDebugElement](WithDebugElement)func WithDebugElement(name string, sourceX, sourceY, targetX, targetY float64) Option
WithDebugElement is an alias for WithDebugLine.

Deprecated: Use WithDebugLine for clarity.


## func WithDebugLine — `rasterize/options.go:109`

[WithDebugLine](WithDebugLine)func WithDebugLine(name string, sourceX, sourceY, targetX, targetY float64) Option
WithDebugLine adds a debug line to the rasterization config.

This can be called multiple times to add multiple debug lines. Each line will be drawn with a label showing the line name.

Coordinates are in mesh space \(same coordinate system as mesh vertices\) and will be automatically transformed to image coordinates.

Example:

	WithDebugLine("edge1", 10.5, 20.3, 100.7, 200.1)
	WithDebugLine("edge2", 100.7, 200.1, 150.2, 50.8)
	


## func WithDebugLocation — `rasterize/options.go:140`

[WithDebugLocation](WithDebugLocation)func WithDebugLocation(name string, x, y float64) Option
WithDebugLocation adds a debug location marker to the rasterization config.

This can be called multiple times to add multiple debug locations. Each location will be rendered as a circle with a label.

Coordinates are in mesh space \(same coordinate system as mesh vertices\) and will be automatically transformed to image coordinates.

Example:

	WithDebugLocation("vertex0", 50.5, 50.3)
	WithDebugLocation("centroid", 100.2, 100.8)
	


## func WithDimensions — `rasterize/options.go:9`

[WithDimensions](WithDimensions)func WithDimensions(width, height int) Option
WithDimensions sets the output image dimensions.


## func WithDrawEdges — `rasterize/options.go:56`

[WithDrawEdges](WithDrawEdges)func WithDrawEdges(enable bool) Option
WithDrawEdges enables or disables edge rendering.


## func WithDrawHoles — `rasterize/options.go:70`

[WithDrawHoles](WithDrawHoles)func WithDrawHoles(enable bool) Option
WithDrawHoles enables or disables hole rendering.


## func WithDrawPerimeters — `rasterize/options.go:63`

[WithDrawPerimeters](WithDrawPerimeters)func WithDrawPerimeters(enable bool) Option
WithDrawPerimeters enables or disables perimeter rendering.


## func WithDrawVertices — `rasterize/options.go:49`

[WithDrawVertices](WithDrawVertices)func WithDrawVertices(enable bool) Option
WithDrawVertices enables or disables vertex rendering.


## func WithEdgeLabels — `rasterize/options.go:28`

[WithEdgeLabels](WithEdgeLabels)func WithEdgeLabels(enable bool) Option
WithEdgeLabels enables or disables edge labels.


## func WithFillTriangles — `rasterize/options.go:42`

[WithFillTriangles](WithFillTriangles)func WithFillTriangles(enable bool) Option
WithFillTriangles enables or disables triangle fills.


## func WithTriangleLabels — `rasterize/options.go:35`

[WithTriangleLabels](WithTriangleLabels)func WithTriangleLabels(enable bool) Option
WithTriangleLabels enables or disables triangle labels.


## func WithVertexLabels — `rasterize/options.go:21`

[WithVertexLabels](WithVertexLabels)func WithVertexLabels(enable bool) Option
WithVertexLabels enables or disables vertex ID labels.


<a name="Palette"></a>
## type Palette

Palette provides a collection of visually distinct colors.

	type Palette struct {
	    // contains filtered or unexported fields
	}

## func HolePalette — `rasterize/palette.go:92`

[HolePalette](HolePalette)func HolePalette() *Palette
HolePalette returns a palette suitable for holes \(darker shades\).


## func NewPalette — `rasterize/palette.go:12`

[NewPalette](NewPalette)func NewPalette() *Palette
NewPalette creates a new color palette with predefined distinct colors.


## func NewTransparentPalette — `rasterize/palette.go:40`

[NewTransparentPalette](NewTransparentPalette)func NewTransparentPalette(alpha uint8) *Palette
NewTransparentPalette creates a palette with semi\-transparent colors.

The alpha parameter \(0\-255\) sets the transparency level for all colors.


## func PerimeterPalette — `rasterize/palette.go:87`

[PerimeterPalette](PerimeterPalette)func PerimeterPalette() *Palette
PerimeterPalette returns a palette suitable for perimeters \(bright, opaque\).


## func TrianglePalette — `rasterize/palette.go:117`

[TrianglePalette](TrianglePalette)func TrianglePalette() *Palette
TrianglePalette returns a palette suitable for triangles \(semi\-transparent\).


## func Get — `rasterize/palette.go:60`

[Get](Palette.Get)func (p *Palette) Get(index int) color.RGBA
Get returns the color at the specified index.

Index wraps around if it exceeds the palette size.


## func Next — `rasterize/palette.go:51`

[Next](Palette.Next)func (p *Palette) Next() color.RGBA
Next returns the next color in the palette.

Colors cycle when the palette is exhausted.


## func Reset — `rasterize/palette.go:65`

[Reset](Palette.Reset)func (p *Palette) Reset()
Reset resets the palette to the beginning.


## func Size — `rasterize/palette.go:70`

[Size](Palette.Size)func (p *Palette) Size() int
Size returns the number of colors in the palette.


## func WithAlpha — `rasterize/palette.go:75`

[WithAlpha](Palette.WithAlpha)func (p *Palette) WithAlpha(alpha uint8) *Palette
WithAlpha returns a new palette with all colors set to the given alpha.


<a name="Transform"></a>
## type Transform

Transform converts mesh coordinates to image coordinates.

	type Transform struct {
	    // contains filtered or unexported fields
	}

## func Apply — `rasterize/rasterize.go:86`

[Apply](Transform.Apply)func (t Transform) Apply(p types.Point) (int, int)
Apply converts a mesh point to image pixel coordinates.


# spatial

	import "github.com/iceisfun/gomesh/spatial"

## Index

- [type HashGrid](<#HashGrid>)
  - [func NewHashGrid\(cellSize float64\) \*HashGrid](<#NewHashGrid>)
  - [func \(h \*HashGrid\) AddVertex\(id types.VertexID, p types.Point\)](<#HashGrid.AddVertex>)
  - [func \(h \*HashGrid\) Build\(\)](<#HashGrid.Build>)
  - [func \(h \*HashGrid\) FindVerticesNear\(p types.Point, radius float64\) \[\]types.VertexID](<#HashGrid.FindVerticesNear>)
- [type Index](<#Index>)


<a name="HashGrid"></a>
## type HashGrid

HashGrid implements Index using a uniform spatial hash grid.

	type HashGrid struct {
	    // contains filtered or unexported fields
	}

## func NewHashGrid — `spatial/hashgrid.go:16`

[NewHashGrid](NewHashGrid)func NewHashGrid(cellSize float64) *HashGrid
NewHashGrid creates a hash grid index with the given cell size.


## func AddVertex — `spatial/hashgrid.go:53`

[AddVertex](HashGrid.AddVertex)func (h *HashGrid) AddVertex(id types.VertexID, p types.Point)
AddVertex adds a vertex to the appropriate cell.


## func Build — `spatial/hashgrid.go:59`

[Build](HashGrid.Build)func (h *HashGrid) Build()
Build is a no\-op for hash grid \(incremental structure\).


## func FindVerticesNear — `spatial/hashgrid.go:27`

[FindVerticesNear](HashGrid.FindVerticesNear)func (h *HashGrid) FindVerticesNear(p types.Point, radius float64) []types.VertexID
FindVerticesNear returns vertices in cells overlapping the query radius.


<a name="Index"></a>
## type Index

Index provides spatial queries for vertices.

	type Index interface {
	    // FindVerticesNear returns vertex IDs within radius of point p.
	    FindVerticesNear(p types.Point, radius float64) []types.VertexID
	    // AddVertex adds a vertex to the index.
	    AddVertex(id types.VertexID, p types.Point)
	    // Build finalizes the index structure.
	    Build()
	}

# types

	import "github.com/iceisfun/gomesh/types"

## Index

- [type AABB](<#AABB>)
- [type Edge](<#Edge>)
  - [func NewEdge\(v1, v2 VertexID\) Edge](<#NewEdge>)
  - [func \(e Edge\) Canonical\(\) Edge](<#Edge.Canonical>)
  - [func \(e Edge\) IsCanonical\(\) bool](<#Edge.IsCanonical>)
  - [func \(e Edge\) V1\(\) VertexID](<#Edge.V1>)
  - [func \(e Edge\) V2\(\) VertexID](<#Edge.V2>)
- [type Epsilon](<#Epsilon>)
  - [func DefaultEpsilon\(\) Epsilon](<#DefaultEpsilon>)
  - [func NewEpsilon\(abs, rel float64\) Epsilon](<#NewEpsilon>)
  - [func \(e Epsilon\) MergeDistance\(a, b Point\) float64](<#Epsilon.MergeDistance>)
  - [func \(e Epsilon\) TolForCoords\(values ...float64\) float64](<#Epsilon.TolForCoords>)
  - [func \(e Epsilon\) TolForPoints\(points ...Point\) float64](<#Epsilon.TolForPoints>)
  - [func \(e Epsilon\) Value\(mag float64\) float64](<#Epsilon.Value>)
  - [func \(e Epsilon\) WithAbs\(abs float64\) Epsilon](<#Epsilon.WithAbs>)
  - [func \(e Epsilon\) WithRel\(rel float64\) Epsilon](<#Epsilon.WithRel>)
- [type IntersectionType](<#IntersectionType>)
- [type Point](<#Point>)
- [type PolygonLoop](<#PolygonLoop>)
  - [func NewPolygonLoop\(vertices ...VertexID\) PolygonLoop](<#NewPolygonLoop>)
  - [func \(p PolygonLoop\) Edges\(\) \[\]Edge](<#PolygonLoop.Edges>)
  - [func \(p PolygonLoop\) NumEdges\(\) int](<#PolygonLoop.NumEdges>)
  - [func \(p PolygonLoop\) NumVertices\(\) int](<#PolygonLoop.NumVertices>)
  - [func \(p PolygonLoop\) Reversed\(\) PolygonLoop](<#PolygonLoop.Reversed>)
  - [func \(p PolygonLoop\) ToPoints\(vp VertexProvider\) \[\]Point](<#PolygonLoop.ToPoints>)
- [type Segment](<#Segment>)
  - [func NewSegment\(start, end VertexID\) Segment](<#NewSegment>)
  - [func \(s Segment\) AsEdge\(\) Edge](<#Segment.AsEdge>)
  - [func \(s Segment\) End\(\) VertexID](<#Segment.End>)
  - [func \(s Segment\) Reversed\(\) Segment](<#Segment.Reversed>)
  - [func \(s Segment\) Start\(\) VertexID](<#Segment.Start>)
  - [func \(s Segment\) Vertices\(\) \(VertexID, VertexID\)](<#Segment.Vertices>)
- [type Triangle](<#Triangle>)
  - [func NewTriangle\(v1, v2, v3 VertexID\) Triangle](<#NewTriangle>)
  - [func \(t Triangle\) Edges\(\) \[3\]Edge](<#Triangle.Edges>)
  - [func \(t Triangle\) V1\(\) VertexID](<#Triangle.V1>)
  - [func \(t Triangle\) V2\(\) VertexID](<#Triangle.V2>)
  - [func \(t Triangle\) V3\(\) VertexID](<#Triangle.V3>)
  - [func \(t Triangle\) Vertices\(\) \[\]VertexID](<#Triangle.Vertices>)
- [type VertexID](<#VertexID>)
  - [func \(v VertexID\) IsValid\(\) bool](<#VertexID.IsValid>)
- [type VertexProvider](<#VertexProvider>)


<a name="AABB"></a>
## type AABB

AABB represents an axis\-aligned bounding box in 2D space.

The bounds are inclusive on all sides. An AABB is valid when Min.X \<= Max.X and Min.Y \<= Max.Y. Empty or inverted AABBs should be handled explicitly by the caller.

Example:

	box := types.AABB{
	    Min: types.Point{X: 0.0, Y: 0.0},
	    Max: types.Point{X: 10.0, Y: 10.0},
	}
	

	type AABB struct {
	    Min Point // Minimum (bottom-left) corner, inclusive
	    Max Point // Maximum (top-right) corner, inclusive
	}

<a name="Edge"></a>
## type Edge

Edge represents an undirected connection between two vertices.

Edges are stored in canonical form with vertex IDs in ascending order, ensuring that Edge\{a, b\} and Edge\{b, a\} compare as equal.

Use NewEdge\(\) to construct edges in canonical form, or use Canonical\(\) to normalize an existing edge.

Example:

	e1 := types.NewEdge(5, 3)  // Stored as Edge{3, 5}
	e2 := types.NewEdge(3, 5)  // Stored as Edge{3, 5}
	// e1 == e2 (true)
	

	type Edge [2]VertexID

## func NewEdge — `types/edge.go:19`

[NewEdge](NewEdge)func NewEdge(v1, v2 VertexID) Edge
NewEdge creates an edge in canonical form \(min ID first\).


## func Canonical — `types/edge.go:27`

[Canonical](Edge.Canonical)func (e Edge) Canonical() Edge
Canonical returns this edge in canonical form.


## func IsCanonical — `types/edge.go:32`

[IsCanonical](Edge.IsCanonical)func (e Edge) IsCanonical() bool
IsCanonical returns true if this edge is in canonical form.


## func V1 — `types/edge.go:37`

[V1](Edge.V1)func (e Edge) V1() VertexID
V1 returns the first vertex ID \(smaller ID in canonical form\).


## func V2 — `types/edge.go:42`

[V2](Edge.V2)func (e Edge) V2() VertexID
V2 returns the second vertex ID \(larger ID in canonical form\).


<a name="Epsilon"></a>
## type Epsilon

Epsilon stores absolute and relative tolerances for geometric operations.

The combined tolerance for a coordinate with magnitude |v| is computed as:

	tol(v) = Abs + Rel * |v|
	

For operations involving multiple coordinates or points, the maximum absolute coordinate magnitude is used. Negative tolerance values are automatically clamped to zero.

	type Epsilon struct {
	    Abs float64
	    Rel float64
	}

## func DefaultEpsilon — `types/epsilon.go:26`

[DefaultEpsilon](DefaultEpsilon)func DefaultEpsilon() Epsilon
DefaultEpsilon returns a conservative default tolerance that roughly matches the mesh package defaults.


## func NewEpsilon — `types/epsilon.go:20`

[NewEpsilon](NewEpsilon)func NewEpsilon(abs, rel float64) Epsilon
NewEpsilon constructs an Epsilon value with the provided parameters.


## func MergeDistance — `types/epsilon.go:86`

[MergeDistance](Epsilon.MergeDistance)func (e Epsilon) MergeDistance(a, b Point) float64
MergeDistance reports the tolerance used for snapping/merging the supplied points. This matches the specification abs \+ rel\*max\(|x|,|y|\).


## func TolForCoords — `types/epsilon.go:71`

[TolForCoords](Epsilon.TolForCoords)func (e Epsilon) TolForCoords(values ...float64) float64
TolForCoords computes the tolerance for the supplied coordinate magnitudes.


## func TolForPoints — `types/epsilon.go:53`

[TolForPoints](Epsilon.TolForPoints)func (e Epsilon) TolForPoints(points ...Point) float64
TolForPoints computes the tolerance to use when comparing any of the given points. It takes the maximum absolute coordinate across all points and applies the combined tolerance.


## func Value — `types/epsilon.go:45`

[Value](Epsilon.Value)func (e Epsilon) Value(mag float64) float64
Value computes the combined tolerance for the supplied coordinate magnitude.

This is a low\-level helper primarily used by TolForPoints/TolForCoords.


## func WithAbs — `types/epsilon.go:31`

[WithAbs](Epsilon.WithAbs)func (e Epsilon) WithAbs(abs float64) Epsilon
WithAbs returns a copy with the absolute tolerance replaced.


## func WithRel — `types/epsilon.go:37`

[WithRel](Epsilon.WithRel)func (e Epsilon) WithRel(rel float64) Epsilon
WithRel returns a copy with the relative tolerance replaced.


<a name="IntersectionType"></a>
## type IntersectionType

IntersectionType classifies the result of a segment\-segment intersection test.

	type IntersectionType int

<a name="IntersectNone"></a>

	const (
	    // IntersectNone indicates the segments do not intersect.
	    IntersectNone IntersectionType = iota
	
	    // IntersectProper indicates segments cross at interior points.
	    IntersectProper
	
	    // IntersectTouching indicates segments share a common endpoint.
	    IntersectTouching
	
	    // IntersectCollinearOverlap indicates collinear segments that overlap.
	    IntersectCollinearOverlap
	)

<a name="Point"></a>
## type Point

Point represents a position in 2D Cartesian space.

Coordinates use float64 precision, suitable for most geometric applications with appropriate epsilon tolerance for comparisons.

Example:

	p := types.Point{X: 1.5, Y: 2.3}
	q := types.Point{X: 0.0, Y: 0.0}
	

	type Point struct {
	    X   float64 // Horizontal coordinate
	    Y   float64 // Vertical coordinate
	}

<a name="PolygonLoop"></a>
## type PolygonLoop

PolygonLoop represents a closed loop of vertices forming a polygon.

The polygon is implicitly closed \(the last vertex connects back to the first\), so the first vertex should NOT be repeated at the end.

Vertices should be ordered consistently \(either all CCW or all CW\) for well\-formed polygons. Self\-intersecting polygons may produce undefined results in some operations.

	type PolygonLoop []VertexID

## func NewPolygonLoop — `types/polygonloop.go:17`

[NewPolygonLoop](NewPolygonLoop)func NewPolygonLoop(vertices ...VertexID) PolygonLoop
NewPolygonLoop creates a polygon loop from vertex IDs.

The vertices should form a closed loop without repeating the first vertex at the end.


## func Edges — `types/polygonloop.go:37`

[Edges](PolygonLoop.Edges)func (p PolygonLoop) Edges() []Edge
Edges returns all edges of the polygon in canonical form.

The loop is treated as closed, so the last edge connects the final vertex back to the first.


## func NumEdges — `types/polygonloop.go:29`

[NumEdges](PolygonLoop.NumEdges)func (p PolygonLoop) NumEdges() int
NumEdges returns the number of edges in the loop.

For a closed loop, this equals the number of vertices.


## func NumVertices — `types/polygonloop.go:22`

[NumVertices](PolygonLoop.NumVertices)func (p PolygonLoop) NumVertices() int
NumVertices returns the number of vertices in the loop.


## func Reversed — `types/polygonloop.go:83`

[Reversed](PolygonLoop.Reversed)func (p PolygonLoop) Reversed() PolygonLoop
Reversed returns a new PolygonLoop with vertices in reverse order.

This flips the winding direction:

- CCW \(counter\-clockwise\) becomes CW \(clockwise\)
- CW becomes CCW

The method is non\-mutating and returns a new PolygonLoop.

Example:

	loop := types.NewPolygonLoop(v0, v1, v2, v3)
	// If loop has CW winding (negative area)
	ccwLoop := loop.Reversed() // Now has CCW winding (positive area)
	


## func ToPoints — `types/polygonloop.go:62`

[ToPoints](PolygonLoop.ToPoints)func (p PolygonLoop) ToPoints(vp VertexProvider) []Point
ToPoints converts the polygon loop to a slice of points using the given vertex provider.

Example:

	points := loop.ToPoints(mesh)
	


<a name="Segment"></a>
## type Segment

Segment represents an oriented connection between two vertices.

Unlike Edge, the vertex order is preserved which is important when the direction encodes polygon winding or constraint orientation.

	type Segment struct {
	    // contains filtered or unexported fields
	}

## func NewSegment — `types/segment.go:13`

[NewSegment](NewSegment)func NewSegment(start, end VertexID) Segment
NewSegment constructs an oriented segment from start to end.


## func AsEdge — `types/segment.go:38`

[AsEdge](Segment.AsEdge)func (s Segment) AsEdge() Edge
AsEdge converts the segment to a canonical undirected edge.


## func End — `types/segment.go:23`

[End](Segment.End)func (s Segment) End() VertexID
End returns the second vertex of the segment.


## func Reversed — `types/segment.go:33`

[Reversed](Segment.Reversed)func (s Segment) Reversed() Segment
Reversed returns a new segment with the opposite orientation.


## func Start — `types/segment.go:18`

[Start](Segment.Start)func (s Segment) Start() VertexID
Start returns the first vertex of the segment.


## func Vertices — `types/segment.go:28`

[Vertices](Segment.Vertices)func (s Segment) Vertices() (VertexID, VertexID)
Vertices returns the start/end vertices in order.


<a name="Triangle"></a>
## type Triangle

Triangle represents an ordered triplet of vertices forming a triangle.

The order of vertices determines the winding direction:

- Counter\-clockwise \(CCW\) order yields positive signed area
- Clockwise \(CW\) order yields negative signed area
- Collinear vertices yield zero \(or near\-zero\) signed area

Triangles are stored exactly as provided; no automatic reordering is performed. Use predicates.Area2 or predicates.Orient to determine winding.

Example:

	t := types.Triangle{0, 1, 2}  // CCW if vertices are positioned appropriately
	

	type Triangle [3]VertexID

## func NewTriangle — `types/triangle.go:20`

[NewTriangle](NewTriangle)func NewTriangle(v1, v2, v3 VertexID) Triangle
NewTriangle creates a triangle from three vertex IDs.


## func Edges — `types/triangle.go:47`

[Edges](Triangle.Edges)func (t Triangle) Edges() [3]Edge
Edges returns the three edges of this triangle in canonical form.

The edges are returned in the order: \(v1,v2\), \(v2,v3\), \(v3,v1\).


## func V1 — `types/triangle.go:25`

[V1](Triangle.V1)func (t Triangle) V1() VertexID
V1 returns the first vertex.


## func V2 — `types/triangle.go:30`

[V2](Triangle.V2)func (t Triangle) V2() VertexID
V2 returns the second vertex.


## func V3 — `types/triangle.go:35`

[V3](Triangle.V3)func (t Triangle) V3() VertexID
V3 returns the third vertex.


## func Vertices — `types/triangle.go:40`

[Vertices](Triangle.Vertices)func (t Triangle) Vertices() []VertexID
Vertices returns all three vertex IDs as a slice.


<a name="VertexID"></a>
## type VertexID

VertexID is a stable integer index into a mesh's vertex array.

VertexID values are assigned sequentially starting from 0 when vertices are added to a mesh. They remain stable for the lifetime of the mesh \(vertices are never removed or reordered\).

The special value NilVertex \(\-1\) represents an invalid or absent vertex reference.

Example:

	var v types.VertexID = 0  // First vertex
	var invalid types.VertexID = types.NilVertex  // Invalid reference
	

	type VertexID int

<a name="NilVertex"></a>NilVertex is a sentinel value representing an invalid or absent vertex.

	const NilVertex VertexID = -1

## func IsValid — `types/vertexid.go:25`

[IsValid](VertexID.IsValid)func (v VertexID) IsValid() bool
IsValid returns true if this VertexID represents a valid vertex reference.

A VertexID is valid if it is non\-negative. Note that this does not guarantee the ID is in range for any particular mesh.


<a name="VertexProvider"></a>
## type VertexProvider

VertexProvider is an interface for types that can provide vertex coordinates.

This allows PolygonLoop methods to work with any type that stores vertices, such as mesh.Mesh or a simple vertex array.

	type VertexProvider interface {
	    GetVertex(id VertexID) Point
	}

# validation

	import "github.com/iceisfun/gomesh/validation"

## Index

- [func CanonicalTriangleKey\(tri types.Triangle\) \[3\]types.VertexID](<#CanonicalTriangleKey>)
- [func PolygonContains\(poly \[\]types.Point, point types.Point, eps float64\) bool](<#PolygonContains>)
- [func PolygonIsValid\(poly \[\]types.Point, eps float64\) bool](<#PolygonIsValid>)
- [func PolygonLoopIsValid\(vp types.VertexProvider, loop types.PolygonLoop, eps float64\) bool](<#PolygonLoopIsValid>)
- [func ValidateEdgeIntersections\(tri types.Triangle, a, b, c types.Point, cfg Config, mesh MeshProvider\) error](<#ValidateEdgeIntersections>)
- [func ValidatePolygon\(poly \[\]types.Point, opts ...PolygonOption\) error](<#ValidatePolygon>)
- [func ValidatePolygonLoop\(vp types.VertexProvider, loop types.PolygonLoop, opts ...PolygonOption\) error](<#ValidatePolygonLoop>)
- [func ValidateTriangle\(tri types.Triangle, a, b, c types.Point, cfg Config, mesh MeshProvider\) error](<#ValidateTriangle>)
- [type Config](<#Config>)
- [type InternalErrors](<#InternalErrors>)
  - [func Errors\(\) InternalErrors](<#Errors>)
- [type MeshProvider](<#MeshProvider>)
- [type PolygonConfig](<#PolygonConfig>)
  - [func DefaultPolygonConfig\(\) PolygonConfig](<#DefaultPolygonConfig>)
- [type PolygonOption](<#PolygonOption>)
  - [func WithAllowSelfIntersection\(allow bool\) PolygonOption](<#WithAllowSelfIntersection>)
  - [func WithPolygonEpsilon\(eps float64\) PolygonOption](<#WithPolygonEpsilon>)
  - [func WithPolygonMaxArea\(area float64\) PolygonOption](<#WithPolygonMaxArea>)
  - [func WithPolygonMaxHeight\(height float64\) PolygonOption](<#WithPolygonMaxHeight>)
  - [func WithPolygonMaxWidth\(width float64\) PolygonOption](<#WithPolygonMaxWidth>)
  - [func WithPolygonMinArea\(area float64\) PolygonOption](<#WithPolygonMinArea>)
  - [func WithPolygonMinHeight\(height float64\) PolygonOption](<#WithPolygonMinHeight>)
  - [func WithPolygonMinWidth\(width float64\) PolygonOption](<#WithPolygonMinWidth>)
  - [func WithRequireCCW\(require bool\) PolygonOption](<#WithRequireCCW>)
  - [func WithRequireCW\(require bool\) PolygonOption](<#WithRequireCW>)
- [type PolygonValidationResult](<#PolygonValidationResult>)
  - [func ValidatePolygonDetailed\(poly \[\]types.Point, opts ...PolygonOption\) PolygonValidationResult](<#ValidatePolygonDetailed>)
  - [func ValidatePolygonLoopDetailed\(vp types.VertexProvider, loop types.PolygonLoop, opts ...PolygonOption\) PolygonValidationResult](<#ValidatePolygonLoopDetailed>)
  - [func \(r PolygonValidationResult\) String\(\) string](<#PolygonValidationResult.String>)


## func CanonicalTriangleKey — `validation/triangle.go:92`

[CanonicalTriangleKey](CanonicalTriangleKey)func CanonicalTriangleKey(tri types.Triangle) [3]types.VertexID
CanonicalTriangleKey returns a sorted key for duplicate detection.


## func PolygonContains — `validation/polygon.go:223`

[PolygonContains](PolygonContains)func PolygonContains(poly []types.Point, point types.Point, eps float64) bool
PolygonContains tests if a point is inside a polygon.

This is a user\-facing convenience wrapper around predicates.PointInPolygonRayCast.

Returns true if the point is inside the polygon or on its boundary.

Example:

	polygon := []types.Point{{0,0}, {10,0}, {10,10}, {0,10}}
	point := types.Point{X: 5, Y: 5}
	if validation.PolygonContains(polygon, point, 1e-9) {
	    // Point is inside polygon
	}
	


## func PolygonIsValid — `validation/polygon.go:203`

[PolygonIsValid](PolygonIsValid)func PolygonIsValid(poly []types.Point, eps float64) bool
PolygonIsValid is a convenience function that checks basic polygon validity.

Returns true if the polygon has at least 3 vertices and does not self\-intersect.


## func PolygonLoopIsValid — `validation/polygon.go:259`

[PolygonLoopIsValid](PolygonLoopIsValid)func PolygonLoopIsValid(vp types.VertexProvider, loop types.PolygonLoop, eps float64) bool
PolygonLoopIsValid checks if a polygon loop is valid \(no self\-intersection\).

Example:

	if validation.PolygonLoopIsValid(mesh, loop, 1e-9) {
	    // Loop is valid
	}
	


## func ValidateEdgeIntersections — `validation/edge.go:12`

[ValidateEdgeIntersections](ValidateEdgeIntersections)func ValidateEdgeIntersections(tri types.Triangle, a, b, c types.Point, cfg Config, mesh MeshProvider) error
ValidateEdgeIntersections checks if triangle edges intersect existing edges.

Also checks that each edge is used by at most 2 triangles \(prevents overlapping triangles that share an edge\).


## func ValidatePolygon — `validation/polygon.go:136`

[ValidatePolygon](ValidatePolygon)func ValidatePolygon(poly []types.Point, opts ...PolygonOption) error
ValidatePolygon validates a polygon against the given configuration.

Returns an error if the polygon fails any validation check.

Example:

	poly := []types.Point{{0,0}, {10,0}, {10,10}, {0,10}}
	err := validation.ValidatePolygon(poly,
	    validation.WithPolygonMinArea(50),
	    validation.WithPolygonMinWidth(5),
	)
	


## func ValidatePolygonLoop — `validation/polygon.go:237`

[ValidatePolygonLoop](ValidatePolygonLoop)func ValidatePolygonLoop(vp types.VertexProvider, loop types.PolygonLoop, opts ...PolygonOption) error
ValidatePolygonLoop validates a polygon loop using a vertex provider.

This is a convenience function that converts the loop to points and validates.

Example:

	err := validation.ValidatePolygonLoop(mesh, loop,
	    validation.WithPolygonMinArea(50),
	    validation.WithRequireCCW(true),
	)
	


## func ValidateTriangle — `validation/triangle.go:43`

[ValidateTriangle](ValidateTriangle)func ValidateTriangle(tri types.Triangle, a, b, c types.Point, cfg Config, mesh MeshProvider) error
ValidateTriangle performs all enabled validation checks on a triangle.


<a name="Config"></a>
## type Config

Config captures validation options required for triangle checks.

	type Config struct {
	    Epsilon                  float64
	    ErrorOnDuplicateTriangle bool
	    ErrorOnOpposingDuplicate bool
	    ValidateVertexInside     bool
	    ValidateEdgeIntersection bool
	}

<a name="InternalErrors"></a>
## type InternalErrors

InternalErrors exposes the validation error sentinels for callers.

	type InternalErrors struct {
	    Degenerate        error
	    Duplicate         error
	    OpposingDuplicate error
	    VertexInside      error
	    EdgeIntersection  error
	}

## func Errors — `validation/triangle.go:116`

[Errors](Errors)func Errors() InternalErrors
Errors returns the error constants used by validation.


<a name="MeshProvider"></a>
## type MeshProvider

MeshProvider exposes the minimal mesh functionality needed for validation.

	type MeshProvider interface {
	    NumVertices() int
	    GetVertex(types.VertexID) types.Point
	    EdgeSet() map[types.Edge]struct{}
	    EdgeUsageCounts() map[types.Edge]int
	    HasTriangleWithKey([3]types.VertexID) (types.Triangle, bool)
	}

<a name="PolygonConfig"></a>
## type PolygonConfig

PolygonConfig holds validation options for a polygon.

	type PolygonConfig struct {
	    Epsilon   float64 // Geometric tolerance
	    MinArea   float64 // Minimum allowed area (0 = no limit)
	    MinWidth  float64 // Minimum bounding box width (0 = no limit)
	    MinHeight float64 // Minimum bounding box height (0 = no limit)
	    MaxArea   float64 // Maximum allowed area (0 = no limit)
	    MaxWidth  float64 // Maximum bounding box width (0 = no limit)
	    MaxHeight float64 // Maximum bounding box height (0 = no limit)
	
	    AllowSelfIntersection bool // Allow self-intersecting polygons
	    RequireCCW            bool // Require counter-clockwise winding
	    RequireCW             bool // Require clockwise winding
	}

## func DefaultPolygonConfig — `validation/polygon.go:110`

[DefaultPolygonConfig](DefaultPolygonConfig)func DefaultPolygonConfig() PolygonConfig
DefaultPolygonConfig returns default validation settings.


<a name="PolygonOption"></a>
## type PolygonOption

PolygonOption configures polygon validation.

	type PolygonOption func(*PolygonConfig)

## func WithAllowSelfIntersection — `validation/polygon.go:89`

[WithAllowSelfIntersection](WithAllowSelfIntersection)func WithAllowSelfIntersection(allow bool) PolygonOption
WithAllowSelfIntersection allows self\-intersecting polygons.


## func WithPolygonEpsilon — `validation/polygon.go:31`

[WithPolygonEpsilon](WithPolygonEpsilon)func WithPolygonEpsilon(eps float64) PolygonOption
WithPolygonEpsilon sets the geometric tolerance.


## func WithPolygonMaxArea — `validation/polygon.go:68`

[WithPolygonMaxArea](WithPolygonMaxArea)func WithPolygonMaxArea(area float64) PolygonOption
WithPolygonMaxArea sets the maximum allowed area.


## func WithPolygonMaxHeight — `validation/polygon.go:82`

[WithPolygonMaxHeight](WithPolygonMaxHeight)func WithPolygonMaxHeight(height float64) PolygonOption
WithPolygonMaxHeight sets the maximum bounding box height.


## func WithPolygonMaxWidth — `validation/polygon.go:75`

[WithPolygonMaxWidth](WithPolygonMaxWidth)func WithPolygonMaxWidth(width float64) PolygonOption
WithPolygonMaxWidth sets the maximum bounding box width.


## func WithPolygonMinArea — `validation/polygon.go:47`

[WithPolygonMinArea](WithPolygonMinArea)func WithPolygonMinArea(area float64) PolygonOption
WithPolygonMinArea sets the minimum allowed area.

This checks the absolute value of the polygon's area, so it works for both CCW \(positive area\) and CW \(negative area\) polygons. Polygons with an absolute area smaller than minArea will be considered invalid \(degenerate\).

Example:

	// Require at least 100 square units
	err := validation.ValidatePolygonLoop(mesh, loop, validation.WithPolygonMinArea(100))
	


## func WithPolygonMinHeight — `validation/polygon.go:61`

[WithPolygonMinHeight](WithPolygonMinHeight)func WithPolygonMinHeight(height float64) PolygonOption
WithPolygonMinHeight sets the minimum bounding box height.


## func WithPolygonMinWidth — `validation/polygon.go:54`

[WithPolygonMinWidth](WithPolygonMinWidth)func WithPolygonMinWidth(width float64) PolygonOption
WithPolygonMinWidth sets the minimum bounding box width.


## func WithRequireCCW — `validation/polygon.go:96`

[WithRequireCCW](WithRequireCCW)func WithRequireCCW(require bool) PolygonOption
WithRequireCCW requires counter\-clockwise winding.


## func WithRequireCW — `validation/polygon.go:103`

[WithRequireCW](WithRequireCW)func WithRequireCW(require bool) PolygonOption
WithRequireCW requires clockwise winding.


<a name="PolygonValidationResult"></a>
## type PolygonValidationResult

PolygonValidationResult holds detailed validation results.

	type PolygonValidationResult struct {
	    Valid          bool
	    Error          error
	    VertexCount    int
	    Area           float64
	    Width          float64
	    Height         float64
	    Bounds         types.AABB
	    IsCCW          bool
	    SelfIntersects bool
	}

## func ValidatePolygonDetailed — `validation/polygon.go:311`

[ValidatePolygonDetailed](ValidatePolygonDetailed)func ValidatePolygonDetailed(poly []types.Point, opts ...PolygonOption) PolygonValidationResult
ValidatePolygonDetailed performs validation and returns detailed results.

This is useful when you want to inspect the polygon properties regardless of whether validation passes or fails.


## func ValidatePolygonLoopDetailed — `validation/polygon.go:247`

[ValidatePolygonLoopDetailed](ValidatePolygonLoopDetailed)func ValidatePolygonLoopDetailed(vp types.VertexProvider, loop types.PolygonLoop, opts ...PolygonOption) PolygonValidationResult
ValidatePolygonLoopDetailed performs detailed validation on a polygon loop.

Example:

	result := validation.ValidatePolygonLoopDetailed(mesh, loop)
	


## func String — `validation/polygon.go:280`

[String](PolygonValidationResult.String)func (r PolygonValidationResult) String() string
String returns a human\-readable description of the validation result.

This is useful for error messages and debugging.


# geometry

	import "github.com/iceisfun/gomesh/algorithm/geometry"

## Index

- [func Area2\(a, b, c types.Point\) float64](<#Area2>)
- [func BBox\(loop \[\]types.Point\) types.AABB](<#BBox>)
- [func Centroid\(a, b, c types.Point\) types.Point](<#Centroid>)
- [func DistancePointSegment\(p, a, b types.Point\) float64](<#DistancePointSegment>)
- [func PointOnSegment\(p, a, b types.Point\) bool](<#PointOnSegment>)


## func Area2 — `algorithm/geometry/geometry.go:13`

[Area2](Area2)func Area2(a, b, c types.Point) float64
Area2 computes twice the signed area of triangle \(a,b,c\).


## func BBox — `algorithm/geometry/geometry.go:65`

[BBox](BBox)func BBox(loop []types.Point) types.AABB
BBox computes the axis\-aligned bounding box of the supplied loop.


## func Centroid — `algorithm/geometry/geometry.go:57`

[Centroid](Centroid)func Centroid(a, b, c types.Point) types.Point
Centroid returns the centroid of triangle \(a,b,c\).


## func DistancePointSegment — `algorithm/geometry/geometry.go:32`

[DistancePointSegment](DistancePointSegment)func DistancePointSegment(p, a, b types.Point) float64
DistancePointSegment computes the shortest distance between a point and a segment.


## func PointOnSegment — `algorithm/geometry/geometry.go:18`

[PointOnSegment](PointOnSegment)func PointOnSegment(p, a, b types.Point) bool
PointOnSegment reports whether point p lies on the closed segment \[a,b\].


# polygon

	import "github.com/iceisfun/gomesh/algorithm/polygon"

## Index

- [func IsCCW\(poly \[\]types.Point\) bool](<#IsCCW>)
- [func ReverseIfNeeded\(poly \[\]types.Point, wantCCW bool\) \[\]types.Point](<#ReverseIfNeeded>)
- [func SignedArea\(poly \[\]types.Point\) float64](<#SignedArea>)
- [type InResult](<#InResult>)
  - [func PointInPolygon\(p types.Point, poly \[\]types.Point\) InResult](<#PointInPolygon>)


## func IsCCW — `algorithm/polygon/polygon.go:32`

[IsCCW](IsCCW)func IsCCW(poly []types.Point) bool
IsCCW reports whether the polygon has counter\-clockwise orientation.


## func ReverseIfNeeded — `algorithm/polygon/polygon.go:37`

[ReverseIfNeeded](ReverseIfNeeded)func ReverseIfNeeded(poly []types.Point, wantCCW bool) []types.Point
ReverseIfNeeded ensures the polygon matches the requested orientation.


## func SignedArea — `algorithm/polygon/polygon.go:18`

[SignedArea](SignedArea)func SignedArea(poly []types.Point) float64
SignedArea computes the signed area of a simple polygon.


<a name="InResult"></a>
## type InResult

InResult categorizes the result of a point\-in\-polygon query.

	type InResult int

<a name="Outside"></a>

	const (
	    Outside InResult = iota
	    OnEdge
	    Inside
	)

## func PointInPolygon — `algorithm/polygon/polygon.go:58`

[PointInPolygon](PointInPolygon)func PointInPolygon(p types.Point, poly []types.Point) InResult
PointInPolygon evaluates the position of a point relative to a polygon.


# pslg

	import "github.com/iceisfun/gomesh/algorithm/pslg"

## Index

- [func EpsilonMerge\(points \[\]types.Point, eps types.Epsilon\) \(\[\]types.Point, \[\]int\)](<#EpsilonMerge>)
- [func LoopSelfIntersections\(loop \[\]types.Point\) error](<#LoopSelfIntersections>)
- [func LoopsIntersect\(a, b \[\]types.Point\) error](<#LoopsIntersect>)
- [func ValidateLoops\(outer \[\]types.Point, holes \[\]\[\]types.Point, eps types.Epsilon\) error](<#ValidateLoops>)


## func EpsilonMerge — `algorithm/pslg/pslg.go:15`

[EpsilonMerge](EpsilonMerge)func EpsilonMerge(points []types.Point, eps types.Epsilon) ([]types.Point, []int)
EpsilonMerge collapses points that are within the supplied tolerance.

It returns the deduplicated slice of points and a remap \(old index \-\> new index\).


## func LoopSelfIntersections — `algorithm/pslg/pslg.go:43`

[LoopSelfIntersections](LoopSelfIntersections)func LoopSelfIntersections(loop []types.Point) error
LoopSelfIntersections checks whether the loop has self\-intersections.


## func LoopsIntersect — `algorithm/pslg/pslg.go:75`

[LoopsIntersect](LoopsIntersect)func LoopsIntersect(a, b []types.Point) error
LoopsIntersect reports whether loops a and b intersect or touch.


## func ValidateLoops — `algorithm/pslg/pslg.go:109`

[ValidateLoops](ValidateLoops)func ValidateLoops(outer []types.Point, holes [][]types.Point, eps types.Epsilon) error
ValidateLoops runs a series of checks to ensure the outer loop and holes form a valid PSLG configuration.


# robust

	import "github.com/iceisfun/gomesh/algorithm/robust"

## Index

- [func InCircle\(a, b, c, d types.Point\) int](<#InCircle>)
- [func Orient2D\(a, b, c types.Point\) int](<#Orient2D>)
- [func SegmentIntersect\(p, q, r, s types.Point\) \(bool, float64, float64\)](<#SegmentIntersect>)


## func InCircle — `algorithm/robust/predicates.go:74`

[InCircle](InCircle)func InCircle(a, b, c, d types.Point) int
InCircle tests whether point d lies inside, on, or outside the circumcircle of triangle \(a,b,c\). The sign of the return value matches the standard predicates convention: positive when inside \(assuming a,b,c are CCW\), negative when outside, and zero when cocircular.


## func Orient2D — `algorithm/robust/predicates.go:25`

[Orient2D](Orient2D)func Orient2D(a, b, c types.Point) int
Orient2D returns the orientation of triangle \(a,b,c\).

The return value is:

- \+1 if the points make a counter\-clockwise turn
- \-1 if the points make a clockwise turn
- 0 if the points are \(near\) collinear

The implementation first evaluates the determinant in float64 with a small adaptive filter and falls back to arbitrary precision arithmetic when necessary.


## func SegmentIntersect — `algorithm/robust/predicates.go:154`

[SegmentIntersect](SegmentIntersect)func SegmentIntersect(p, q, r, s types.Point) (bool, float64, float64)
SegmentIntersect computes whether two closed segments \[p,q\] and \[r,s\] intersect.

When the segments share a single intersection point, the second and third return values represent the parametric coordinates along pq and rs respectively. They lie in the range \[0,1\].

For collinear overlaps \(infinitely many intersection points\), the function returns true and both parameters are NaN.


# add\_perimeter

	import "github.com/iceisfun/gomesh/cmd/add_perimeter"

## Index



# cdt\_example

	import "github.com/iceisfun/gomesh/cmd/cdt_example"

## Index



# diagnose\-candidates

	import "github.com/iceisfun/gomesh/cmd/diagnose-candidates"

## Index



# hole\_inside\_hole

	import "github.com/iceisfun/gomesh/cmd/hole_inside_hole"

## Index



# hole\_inside\_perimeter

	import "github.com/iceisfun/gomesh/cmd/hole_inside_perimeter"

## Index



# hole\_outside\_perimeter

	import "github.com/iceisfun/gomesh/cmd/hole_outside_perimeter"

## Index



# intersecting\_holes

	import "github.com/iceisfun/gomesh/cmd/intersecting_holes"

## Index



# overlapping\_perimeters

	import "github.com/iceisfun/gomesh/cmd/overlapping_perimeters"

## Index



# polygon\_validation

	import "github.com/iceisfun/gomesh/cmd/polygon_validation"

## Index



# rasterize

	import "github.com/iceisfun/gomesh/cmd/rasterize"

## Index



# rasterize\_perimeters\_holes

	import "github.com/iceisfun/gomesh/cmd/rasterize_perimeters_holes"

## Index



# rasterize\_triangles\_alpha

	import "github.com/iceisfun/gomesh/cmd/rasterize_triangles_alpha"

## Index



# two\_holes\_inside\_perimeter

	import "github.com/iceisfun/gomesh/cmd/two_holes_inside_perimeter"

## Index



# validate

	import "github.com/iceisfun/gomesh/cmd/validate"

## Index



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
